I"N<h3 id="java와-kotlin-클래스의-차이점">Java와 Kotlin 클래스의 차이점<br /></h3>
<p>① 코들린 클래스와 Java 클래스의 차이점 중 하나는 코틀린은 ‘Getter, Setter’가 자동 생성된다.<br />
② 코틀린 클래스에서 ‘var’로 선언한 변수는 getter,setter 전부 생성되고, ‘val’키워드로 선언된 변수는 getter만 선언된다.<br />
③ 코틀린에서 field변수에 대한 setter method를 customize해서 사용해야 되는 경우가 있는데, 이 경우에는 다음과 같이 <br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var nickName = ""
    set(value){
      field = value.toLowerCase()
    }
</code></pre></div></div>

<p>위와 같은 문법을 사용하는 이유는 ‘Property의 이름’을 사용하는 경우, 자동으로 Setter, Getter가 호출되기 때문이다. <br />
접근자(Getter, Setter)에서 field키워드로 사용되는 개념을 ‘Property를 뒷받침하는 field’라는 의미의 ‘Backing Field’라 불린다.<br />
Kotlin에서는 field를 사용하지 않기 때문에 이렇게 field키워드를 사용해서 접근한다.</p>

<p>Property의 위임은 코틀린이 객체의 Property를 더욱 유연하게 활용할 수 있도록 지원하는 기능 <br /></p>

<h3 id="property와-field의-차이점-">Property와 Field의 차이점 <br /></h3>
<p>코틀린은 기본적으로 Field를 사용하지 않는다.<br /></p>

<p>Field는 클래스에 선언되어 있는, ‘클래스 변수’가 아닌 ‘인스턴스 변수’를 의미한다.<br />
필드는 외부에서 접근할 수 있는 Getter, Setter 메소드가 반드시 존재할 필요가 없다.따라서 Getter, Setter는 있건 없건 상관없다.<br /></p>

<p>클래스의 인스턴스 변수들을 모두 Field라고 부릅니다. Getter, Setter가 있든 없든, 혹은 접근 제어자가 무엇이든 Field이다. <br /></p>

<p><strong><font color="Red">반면, Property는 조금 다르다!</font></strong><br />
① Field가 선언되어 있고 Getter, Setter가 있는 경우 Property이다.<br />
② Getter만 선언되어 있어서, 변수의 값을 읽을수만 있는 경우도 Property이다.<br />
③ 단순 Field는 Property가 아니다. <strong>ex) private int notProperty1 = 0;</strong><br />
④ 클래스 변수 역시 Property가 아니다. <strong>ex) private static int notProperty2;</strong> <br /></p>

<p>※ Property는 Field와 외부에서 접근 가능한 Getter 또는 Setter가 있는 경우이다. 더 정확히 말하면 Property는 Field와 접근 가능한 Getter, Setter의 조합을 의미한다.<br /></p>

<p>코틀린은 기본적으로 클래스의 상속을 불가능하다. <br />
이렇게 만든 이유는 Java분야의 유명서적 ‘Effective Java’에서는 상속에 대하여 ‘상속을 위한 설계와 문서를 갖추거나, 그렇지 않은 경우 상속을 금지하라’라고 조언한다. <br />
캡슐화의 주요 목적 중 하나는 클래스를 사용하는 측면에서 해당 클래스의 구체적인 사항을 모르게 하는 것입니다. 하지만, 구체적인 구현 클래스를 알고 있는 상태에서 구현해야하는 상황이 발생한다면, 이는 “캡슐화가 깨졌다”라고 볼 수 있다.<br />
Kotlin에서 상속을 허용하려면, ‘open’키워드를 사용해야 한다.<br />
코틀린에서 클래스의 메소드는 기본적으로 ‘final’상태이기 때문에, 클래스뿐만 아니라 메소드 역시 open처리를 해야 override할 수 있다!<br />
Override하는 함수에 대해서는 반드시 ‘override’키워드를 사용해야만 한다.<br /></p>

<h1 id="위임--코틀린에서-상속의-단점을-줄이고-코드를-재사용할-수-있다">‘위임’ : 코틀린에서 상속의 단점을 줄이고 코드를 재사용할 수 있다.<br /></h1>
<h3 id="클래스와-프로퍼티의-위임">클래스와 프로퍼티의 위임<br /></h3>
<p><strong><font color="Blue">객체 지향에서 위임이란?</font></strong><br />
클래스의 특정 기능들을 대신 처리해 주는 것을 말한다.<br /></p>

<p><strong>클래스를 상속하지 않고 기존 클래스의 일부 메소드를 변경하거나 새로운 기능을 확장하는 방법은 ‘위임’이다. </strong><br />
<strong>위임을 사용하는 대표적인 패턴에는 <font color="Red">데코레이터(Decorator)패턴</font>이 있다.</strong><br /></p>

<p><strong><font color="Red">'데코레이터 패턴'</font></strong>은 그 이름처럼 특정 클래스의 기능에 추가 기능을 덧붙이는 방법이다.<br />
<strong>‘기존에 설계된 객체에서 책임을 전달하는 것’</strong>이 ‘위임’입니다. 확장 기능은 자신이 실행하고, 기존의 기능은 그대로 기존 객체의 메소드에 전달하는 방식이다.<br /></p>

<p>데코레이터 패턴은 이런 위임을 활용한 패턴 중 하나로, 보통 기존 기능에 추가 기능을 덧붙이는 패턴이다. 데코레이터 패턴을 활용하면 기존 클래스를 상속받지 않은 상태로 새로운 추가 기능을 덧붙이거나 확장할 수 있다.<br /></p>

<p>문제는 이런 Decorator 패턴의 경우, 단순한 경우에도 코드가 상당히 길어진다는 것이다. 인터페이스에 포함된 메소드가 많다면 코드가 매우 길어진다. 그 이유는 일단은 인터페이스의 모든 메소드를 구현해야 한다.<br /></p>

<p>코틀린은 클래스 위임을 언어 차원에서 제공하기 때문에, 훨씬 간결하게 표현할 수 있다.<br />
<strong>ex)</strong> ‘by’ 명령어를 이용해서 인터페이스의 기능을 위임<br />
class DelegatingArrayList<T>(private val innerList: MutableCollection<T> = mutableListOf()) : MutableCollection<T> by innerList<br /></T></T></T></p>

<p>→ 위의 코틀린 코드는 ‘innerList’라는 ArrayList타입의 Property가 있고, ‘Collection’인터페이스를 상속받고, <strong>&lt;font color=”Red&gt;Collection 인터페이스의 기능을 ‘innerList’에 위임&lt;/font&gt;</strong>하겠다”는 의미이다.<br /></p>
:ET