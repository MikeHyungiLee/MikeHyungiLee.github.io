I""<h3 id="kotlin-singleton-example-with-mvvm-and-coroutines">Kotlin Singleton Example with MVVM and coroutines<br /></h3>

<p>이번 Post에 정리할 내용은 아래와 같다.<br />
2 examples :<br /></p>

<p>1) Quick “how to”<br /></p>

<p>2)Practical example<br />
-Retrofit<br />
-Coroutines<br />
-MVVM<br /></p>

<p>Singletons</p>

<p>Instance of an object <br />
reuse the instance <br />
Retrofit instance <br />
Repository instance <br />
User sessions <br />
Dagger(Dependency Injection/Provide Singleton)
Dagger라이브러리는 좀 어렵다. 나중에 별도의 강의로 이해하도록 하자.<br /></p>

<p><strong><font color="Red">자 이제 실제로 Singleton 패턴의 클래스를 Kotlin으로 작성해보자.</font></strong><br /></p>

<p>① 우선 models패키지를 작성을 하고, 그 안에 User라는 data class를 작성해준다. <br />
② 다음으로 ExampleSingleton을 이름으로 하는 Object클래스를 작성한다. 이 클래스 안에는 앞서 작성한 User클래스를 아래와 같이 객체를 만들어준다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val singletonUser: User by lazy {
  User("email@gmail.com", "username", "image.png")
}
</code></pre></div></div>

<p><strong>lazy키워드를 사용해서 변수를 위임하면 실제로 해당 속성이 호출되서 사용될때, 초기화가 된다.<br />
(클래스가 인스턴스화되는 타이밍에는 해당 속성은 메모리상에 초기화되지 않는다) </strong><br /></p>

<p>③ MainActivity의 onCreate 메소드 내에서 Singleton클래스 내부에서 작성한 singletonUser 변수의 hashCode를 확인해서 실제 화면의 configuration(portrait/landscape)가 변경이 되었을때, 같은 메모리 주소를 반환하고 있는지 확인해본다. <br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>println("DEBUG: ${ExampleSingleton.singletonUser.hashCode()}")
</code></pre></div></div>

<p>아래와 같이 화면의 configuration을 바꿨을때, 매번 같은 hashCode를 반환함을 알 수 있다.<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
</code></pre></div></div>

<p>④ 다음으로, api 패키지를 작성하고, MyRetrofitBuilder(Object클래스)와 ApiService 인터페이스를 작성해볼 것이다. <br />
MyRetrofitBuilder클래스를 Object클래스 타입으로 작성하는 이유는 Kotlin에서는 Object클래스로 작성한다는 의미가 바로 ‘Singleton’으로 작성하겠다는 의미이기 때문이다. ApiService인터페이스에서는 Retrofit을 사용해 통신상으로터 데이터를 취득하는 메소드를 작성할 것이다.<br />
<strong><font color="Blue">MyRetrofitBuilder.kt</font></strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object MyRetrofitBuilder {

    const val BASE_URL = "https://open-api.xyz/"

    // Singleton Retrofit builder
    val retrofitBuilder: Retrofit.Builder by lazy {
      Retrofit.Builder()
      .baseUrl(BASE_URL)
      .addConverterFactory(GsonConverterFactory.create())
      // 서버로부터 호출되는 데이터의 형식은 JSON형태이므로, 이를 Convert할 Converter가 필요하다.
      // Gson Converter = JSON objcet -&gt; Java object
    }

    // Singleton apiService (Network request)
    val apiService: ApiService by lazy {
      retrofitBuilder
      .build()
      .create(ApiService::class.java)
    }

}
</code></pre></div></div>

<p><strong><font color="Blue">ApiService.kt</font></strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface ApiService {

    @GET("placeholder/user/{userId}")
    // 여기서 사용되는 suspend fun은 'coroutine'을 사용하기 위한 fun이다.
    // use 'coroutine' fun return the date from network.
    suspend fun getUser(
        @Path("userId") userId: String
    ): User
}
</code></pre></div></div>

<p>‘suspend fun’을 사용하면 ‘coroutine’을 사용한다는 의미이다. <br /></p>

<p>⑤</p>

<h3 id="전체적인-학습내용을-복습한다">전체적인 학습내용을 복습한다.<br /></h3>
<ol>
  <li><br /></li>
</ol>
:ET