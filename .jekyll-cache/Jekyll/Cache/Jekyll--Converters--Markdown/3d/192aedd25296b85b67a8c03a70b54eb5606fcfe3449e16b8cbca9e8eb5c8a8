I"6<p>이번에 포스팅에서는 ListView, RecyclerView, ViewHolder의 개념들에 대해서 공부하면서 간단한 어플을 만들어 볼 것이다.</p>

<h3 id="-model-data-structure"><strong><font color="Blue">① Model (Data structure)</font></strong></h3>
<p>우선적으로 생각해야되는 부분은 View에 보여줄 data의 구조이다.<br />
이번에 예시로 만들어 볼 어플에서는 categories와 product 항목이 있다. 따라서 이 항목들을 객체화할 class를 작성할 것이다.<br />
ex) Category, Product<br />
위의 View에 보여줄 data객체의 class는 전부 <strong>“models” package</strong>안에 작성을 해줄 것이다.<br /></p>

<h3 id="-controller"><strong><font color="Blue">② Controller</font></strong></h3>
<p>다음으로 <strong>“controllers” package</strong>를 작성해준다. 이 안에는 기본 생성되는 MainActivity가 위치한다.</p>

<h3 id="-services"><strong><font color="Blue">③ Services</font></strong></h3>
<p>다음으로 <strong>“services” package</strong>를 작성해준다. 파일을 작성할때는 File type을 Object로 하고, 이름은 DataService로 작성한다.<br />
안에 작성하게 될 내용은, Google에서 “Kotlin object singleton” 이라고 검색을 해서 작성법에 대해서 이해하고 작성하면 된다. → <a href="https://kotlinlang.org/docs/reference/object-declarations.html">Kotlin object singleton</a> <br /></p>

<p>다음과 같이 각 항목의 List data를 선언해준다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object DataService {

  val categories =  listOf(
      Category("SHIRTS", "shirtimage"),
      Category("HOODIES", "hoodieimage"),
      Category("HATS", "hatimage"),
      Category("DIGITAL", "digitalgoodsimage"),
      ....
      )

  val hats = listOf(
      Product("Devslopes Graphic Beanie","$18","hat1"),
      Product("Devslopes Graphic Black","$20","hat2"),
      ....
      )

  val hoodies = listOf(
      Product("Devslopes Hoodie Gray","$28", "hoodie1"),
      Product("Devslopes Hoodie Red","$30", "hoodie2"),
      ....
      )

  val shirts = listOf(
      Product("Devslopes Shirt black","$28", "shirt1"),
      Product("Devslopes Shirt Red","$20", "shirt2"),
      ....
      )

  val digitalGood = listOf&lt;Product&gt;()

  fun getProducts(category: String) : List&lt;Product&gt;{
      return when(category){
          "SHIRTS"-&gt; return shirts
          "HATS" -&gt; return hats
          "HOODIES" -&gt; return hoodies
          else -&gt; return digitalGood
        }
    }
}
</code></pre></div></div>

<p>ListView와 Adapter, Data의 관계[?]에 대해서 이해를 해보자. 우선 UI에는 ListView가 추가되어있고, 이 ListView에 표시하고자 하는 데이터가 필요하다. 이 Data는 raw data인데 이를 알맞게 ListView에 formatting해서 표시해주는 역할을 하는 것이 바로 <strong>Adapter</strong>이다.</p>

<p><img src="/images/android/2020-04-08 data, adapter, ListView.png" alt="blog capture" width="500" title="capture img" /><br /></p>

<p>이 Adapter는 Controller Package의 class에 작성해준다.
자 그럼 이제 Android에서 기본적으로 제공되는 Layout을 활용해서 Adapter를 작성해 볼 것이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MainActivity : AppCompatActivity() {

    lateinit var adapter: ArrayAdapter&lt;Category&gt;

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        adapter = ArrayAdapter(this,
                               android.R.layout.simple_list_item_1,
                               DataService.categories)
        // ArrayAdapter([context], [android default layout], [data list object])                       
        listView.adapter = adapter
    }  
}    
</code></pre></div></div>

<p>이제는 <strong><font color="Red">ListView를 Customize</font></strong>해서 만들어 볼 것이다.<br />
새로운 레이아웃 파일을 생성한다. layout/category_list_item.xml 생성.</p>

<p>Customized ListAdapter<br />
① adapters package를 작성하기.  <br />
② CategoryAdapter class를 작성하고, <strong>BaseAdapter</strong> class를 상속한다.<br />
③ <strong>getView()</strong> : 가장 큰 mothod, <strong>getItem()</strong> : position parameter를 사용해서 item을 취득하는 것, <strong>getItemId()</strong> : 이 method는 사용되지 않을 것이므로, return 0 처리를 해준다.<br /></p>

<p>※ 우리가 저번시간에 Adapter를 초기했을때, 사용한 각 요소를 확인해보면, context와 layout요소 그리고 각 layout리스트에 초기화 시켜주기 위한 data set이 필요했다.<br /></p>

<p>※ 우리는 이번 custom list view 클래스를 초기화시켜줄때, context와 data set을 parameter로써 선언해서 adapter를 초기화시켜 줄 것이다.</p>

<table>
  <tr>
    <td width="500">
      <img src="/images/android/2020-04-08 custom adapter.png" alt="blog capture" width="500" title="capture img" />
    </td>
    <td width="500">
      <div>
          override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {<br />
          <strong>Position</strong> - index path<br />
          <strong>convertView</strong> - view that is displayed over and over<br />
          <br />
      </div>
    </td>
  </tr>
</table>

<table>
  <tr>
    <td width="500">
      <img src="/images/android/2020-04-08 LayoutInflater.png" alt="blog capture" width="700" title="capture img" />
    </td>
    <td width="500">
      <div>
        Inflater is an object that takes in XML layout like we have here in out layouts folder in this category list items and it turns it into an actual view that we can use in code.<br />
        We have inflated a view that we are calling category view from the XML file called category.<br />
        이 방법이 최선은 아니다. 왜냐하면 화면을 스크롤할때 마다 매번 getView 메소드가 호출되고 초기화되고 있기 때문이다.
      </div>
    </td>
  </tr>
</table>
<p><strong><font color="red">※ 개선후 코드</font></strong></p>
<table>
  <tr>
    <td width="500">
      <img src="/images/android/2020-04-09 getView.png" alt="blog capture" width="700" title="capture img" />
    </td>
    <td width="500">
      <div>
        getView 메소드에서 화면의 UI요소가 매번 초기화되는 비효율적인 부분을 refactoring해줄 것이다.<strong>(Prevent from heavy computing)</strong><br />  
        viewHolder paradigm<br />
        오직 한 번 layout을 Inflate해준다. (레이아웃과 UI Element를 재활용한다)<br />
        ListView에서는 ViewHolder를 사용하는 것은 Option이지만, <strong><font color="Red">※RecyclerView에서는 ViewHolder를 필수적으로 사용해야한다.</font></strong><br />


      </div>
    </td>
  </tr>
</table>
<h3 id="recyclerview와-listview의-차이-">RecyclerView와 ListView의 차이 <br /></h3>
<p>RecyclerView를 사용하게 되면 ViewHolder의 사용은 필수이기 때문에 좀 더 부드러운 scroll과 최적화된 ListView를 사용할 수 있다. 그리고 큰 용량의 data set을 사용할때도 최적화시킬 수 있다.<br />
하지만, <font color="Red"><u>RecyclerView는 ListView와 같이 built-in method (onItemClickListener)같은 method를 제공하지는 않는다.</u></font><br />
RecyclerView를 사용할때는 standard SDK를 사용하지 않고, support library를 사용하기 위해 dependency를 추가해주어야 한다.<br /></p>

<p><strong>Support library란?</strong><br />
→ <a href="https://developer.android.com/topic/libraries/support-library?hl=Language">https://developer.android.com/topic/libraries/support-library?hl=Language</a>
<br />
AndroidX는 기존 Android 지원 라이브러리를 크게 개선한 것으로, androidx 패키지는 동일한 기능과 새로운 라이브러리를 제공하여 지원 라이브러리를 완전히 대체한다.<br />
<br />
The RecyclerView Support Library and RecyclerView AndroidX library are having the same purpose. The main difference is the package name. The AndroidX mainly a repackage and re-branded support library with the main purpose to ease the Android development process. All the support library capabilities is still existed in AndroidX, but the newest capabilities and development shifted to AndroidX now.</p>

<p>(Android Jetpack) Androidx를 사용해서 RecyclerView를 구현하는 경우에는 <strong>“implementation “androidx.recyclerview:recyclerview:1.1.0”</strong>를 dependency에 추가한다.<br /></p>

<p><strong><font color="Red">※ RecyclerView Class 작성하기</font></strong><br />
① RecyclerView.Adapter를 상속받아서 <strong>RecyclerView클래스를 작성</strong>해준다.<br />
② <strong>ViewHolder 내부 클래스를 작성</strong>해준다. 기존의 ListView의 ViewHolder의 inner class에서는 아무것도 상속하지 않고 작성했지만, <strong>RecyclerView의 ViewHolder에서는 RecyclerView.ViewHolder를 상속해서 작성</strong>해준다.<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CategoryRecycleAdapter : RecyclerView.Adapter&lt;CategoryRecycleAdapter.holder&gt;(){

    inner class holder(itemView: View) : RecyclerView.ViewHolder(itemView) {

    }
}
</code></pre></div></div>

<p>③ RecyclerView class에도 override method들을 추가해준다.<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CategoryAdapter(val context: Context, val categories: List&lt;Category&gt;) : BaseAdapter {
</code></pre></div></div>

<p>RecyclerView class에도 다음과 같이 parameter에 context와 dataSet변수를 constructor로 초기화시켜서 처리해준다.<br /></p>

<p>④ RecyclerView 클래스의 Override method<br /></p>

<ul>
  <li><strong>onBindViewHolder()</strong> - display the data at the specified location <br />
(binding is the process of preparing a child view to display data according to the position within adapter)</li>
  <li>
    <p><strong>onCreateViewHolder()</strong> - When new holders are needed <br />
ListView에서의 같은 부분 :<br />
<img src="/images/android/2020-04-09 onCreateViewHolder.png" alt="blog capture" width="500" title="capture img" /><br /></p>
  </li>
  <li>
    <p><strong>Holder inner class</strong> - UI element binding <br />
ListView에서의 같은 부분 :<br />
<img src="/images/android/2020-04-09 Holder inner class.png" alt="blog capture" width="500" title="capture img" /><br /></p>

    <p>기존의 ListView class의 getView method에서 UI element의 binding처리를 해주었다.<br />
<strong>이 작업을 RecyclerView에서는 Holder inner class에서 처리</strong>해준다.<br />
<strong>이 Holder inner class에서만든 내용을 onBindViewHolder method에서 호출하기 위해 Holder inner class내부에 개별적인 method의 작성이 필요</strong>하다.<br />
<img src="/images/android/2020-04-09 onBindViewHolder.png" alt="blog capture" width="700" title="capture img" /><br /></p>
  </li>
  <li>
    <p><strong>onCreateViewHolder()</strong> - inflate the view for the very first time.<br />
RecyclerView가 사용할 layout이 없을때 layout inflate가 실행되는 method.<br /></p>

    <p><code class="highlighter-rouge">val view = LayoutInflater.from()</code><br />
layout을 inflate할때, 생성자를 통해 받은 context를 사용해도 되고, method자체에서 parameter로 받고 있는 parent변수를 받아서 처리해도 된다.<br />
<img src="/images/android/2020-04-09 LayoutInflater.png" alt="blog capture" width="600" title="capture img" /><br /></p>
  </li>
</ul>

<p>⑤  ListVie와 다르게 RecyclerView에서는 한 가지 더 설정해줘야하는 부분이 있다.<br />
    바로 <strong><font color="Red">Layout manager</font></strong><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Layout manager - layout manager positions item views inside a recycler view and determines
</code></pre></div></div>

<p><img src="/images/android/2020-04-09 Layout manager.png" alt="blog capture" width="600" title="capture img" /><br /></p>

<p>이미 화면에 출력된 적이 있는 data set의 경우에는 재사용을 하고, 재사용을 할 경우에는, layout manager는 adapter에게 다른 컨텐츠 뷰로 교체할 것을 물을 것이다. <br />
이러한 컨셉은 불필요한 뷰의 생성과 매우 무거운 findViewById() lookup작업을 피함으로써 어플리케이션의 퍼포먼스를 좋게 만들 것이다.<br /></p>

<p><img src="/images/android/2020-04-09 LayoutManager.png" alt="blog capture" width="500" title="capture img" /><br /></p>

<p>⑥　RecyclerView Clicks</p>

<p>RecyclerView는 built-in onClickListener method가 없기 때문에, Lambda식으로 RecyclerView의 click 이벤트를 처리해줘야 한다.<br />
기존에 선언한 CategoryRecycleAdapter에서 Parameter로 넘겼던 context, dataset과 함께 <strong>itemClick:(Category)-&gt;Unit</strong> 넘겨줘야 한다.<br />
클릭을 했을때, Category 객체를 넘겨주지만, 결과적으로 아무것도 반환하지 않기 때문에, Unit으로 처리를 해준다.<br />
<br />
그 다음에는 이렇게 넘긴 itemClick 인수를 Holder inner class에 선언해준다.<br /></p>

<p>최종적으로 RecyclerView에서 Lambda</p>

<blockquote>
  <blockquote>
    <p>2020-04-08 LayoutInflater</p>
  </blockquote>
</blockquote>

<p>※ 직접 내 GitHub에 Repository추가해서 실습하기 <br />
내 GitHub Repository 주소 :</p>
:ET