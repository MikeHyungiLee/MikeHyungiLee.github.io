I"2<h3 id="apply-"><strong>.apply ?</strong><br /></h3>

<p>우선 .apply를 사용해서 recyclerView의 LayoutManager와 adapter를 초기해준 아래 예를 같이 살펴보자. <br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private fun initRecyclerView(){
    // apply 를 사용해서 layoutManager 와 adapter 를 지정해주었을때,
    recycler_view.apply {
        layoutManager = LinearLayoutManager(this@MainActivity)
        blogAdapter = BlogRecyclerAdapter(context,[dataSet])
        adapter = blogAdapter
    }

    // recycler_view를 지정해주면서 layoutManager 와 adapter 를 지정해주었을때
    recycler_view.layoutManager = LinearLayoutManager(this@MainActivity)
    blogAdapter = BlogRecyclerAdapter(this,[dataSet])
    recycler_view.adapter = blogAdapter
}
</code></pre></div></div>

<p>확실히 apply annotation을 사용해서 recycler_view를 초기화 시켜주면, 매번 recycler_view를 호출해서 사용하지 않아도 가볍게 layoutManager와 adapter 키워드만으로도 초기화 시켜줄 수 있다.</p>

<h3 id="companion-object-"><strong>companion object ?</strong><br /></h3>

<p>Kotlin은 클래스에 static 필드를 갖게 할 수는 없지만, companion object의 구조를 이용해서 Java의 static 메소드와 동일한 동작을 수행할 수 있다.<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data class Book(val title: String, val price: Int){
    companion object {
        const val FREE_PRICE = 0
        fun newFreeBook(title: String) = Book(title, FREE_PRICE)
    }
}

fun main(){
  val book = Book.newFreeBook("Free Kotlin")
  println(book)
}
</code></pre></div></div>

<p>위와 같이 companion object 뒤의 {}안에는 일반 클래스의 본체와 같이 구현을 한다. 위와 같이 도우미 개체를 정의하면 Book 클래스 안에 내재 된 싱글 톤 인스턴스(Singleton Instance)가 생성되며, Book.[Field name]형태로 액세스 할 수 있다. <br /></p>

<p>companion object는 <strong><font color="Red">자체가 클래스 정의를 가지고 있으며, 외부에서 정의 된 클래스의 인스턴스가 아니다.</font></strong><br />
Book.xxx()라는 접근방식을 보면, 마치 Book 클래스의 싱글톤 인스턴스가 만들어지고 있는 것처럼 보이지만, Book인스턴스가 만들어지는 것은 아니다.<br />
위의 Book.xxx()라는 문장은 사실 <strong>Book.Companion.xxx()</strong>이 생략 기법이다. 이 점에서 companion object는 Book 클래스의 인스턴스와는 별개임을 알 수 있다.<br /></p>

<p>위와 같이 companion object{}의 형태로 작성할 수 있지만, 이 companion object에 이름을 넣어줄 수도 있다.<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data class Book(val title: String, val price: Int){
    companion object Factory{
      const val FREE_PRICE = 0
      fun freeBook(title: String) = Book(title, FREE_PRICE)
    }
}
</code></pre></div></div>

<p>위의 도우미 객체는 Book.Factory.[Field name] 형태로 액세스 할 수 있다.<br />
<strong>companion object는 클래스 내에서 하나 밖에 정의할 수 없다.</strong></p>

<h3 id="coroutine--"><strong>Coroutine ?</strong> <br /></h3>

<p>‘Coroutine’에 대해 알아보기 전에 우선, ‘동기’와 ‘비동기’의 개념에 대해서 알아보자.<br />
<strong><font color="Red">동기(Synchronous) : will run in the same thread.</font></strong><br />
ex1)
    // 메인 스레드에서 실행
    fun runMain(){
      val data = Weather.tomorrow()
      println(“Tomorrow weather : ${data}”)
    }</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun Weather.tomorrow() : String{
  Thread.sleep(2000)
  return "sunny"
}
</code></pre></div></div>

<p>위의 ‘ex1’의 코드에서는 모두 Main Thread에서 실행하는 소스코드이다. 이는 동기적으로 호출해서 사용되고 있는 예이다.<br />
동기적 처리는 2초 스레드가 차단되어버리는 문제가 있다. 이 스레드가 차단되는 동안에는 사용자의 조작이 얼어 버리기 때문에 응용 프로그램에서 이 코드를 작성하는 것은 현실적이지 않다. 한편 coroutin을 사용하면 결과가 나올 때까지 2초 사용자가 일반적으로 수행할 수 있다.<br /></p>

<p>위의 차이가 나는 이유는 <strong>coroutine에서 스레드를 차단하는 대신 처리를 <font color="Red">"중단"</font>하기 때문이다.</strong><br />
첫번째 소스 코드에서 Thread.sleep() 따라 2초 main thread를 점유(차단)하고, 그 동안 다른 작업을 하고 싶어도 메인 스레드가 사용할 수 없다. <br />
한편 coroutine의 예에서 사용한 delay()함수는 2초간 차단하는 것이 아니라 <strong>main thread를 2초 동안 방출</strong>하고  main thread를 다시 취득하고 처리를 계속한다. main thread가 개방되는 동안 다른 process에 thread를 활용할 수 있다. <strong><font color="Red">"중단(suspend)"</font></strong></p>

<p><strong><font color="Red">비동기(Asynchronous) : will run in a different thread.</font></strong><br /></p>

<h3 id="전체적인-학습내용을-복습한다">전체적인 학습내용을 복습한다.<br /></h3>
<p>1.</p>
:ET