<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lee Hyungi's Tech Blog</title>
    <description>Hyungi's Ideas &amp; Blogs</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 17 Apr 2020 05:27:30 +0900</pubDate>
    <lastBuildDate>Fri, 17 Apr 2020 05:27:30 +0900</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Android Jetpack Navigation Component</title>
        <description>&lt;h3 id=&quot;android-jetpack-navigation-component&quot;&gt;Android Jetpack Navigation Component&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 포스팅에서는 Jetpack Navigation Component를 활용하여 Fragment간의 전이 처리하는 것에 대해서 배워 볼 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;① app gradle에 dependencies 추가하기&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def nav_version = &quot;2.3.0-alpha05&quot;
// Kotlin
implementation &quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;
implementation &quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;

def material_version = &quot;1.2.0-alpha05&quot;
implementation &quot;com.google.android.material:material:$material_version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;※ navigation graph 기능&lt;/p&gt;

&lt;p&gt;(1) resouce - [New Resource File] - (File name : nav_graph / Resource type : Navigation)&lt;br /&gt;
(2) 위의 nav_graph 파일에 화면에 보여질 UI의 화면 설계구조를 구조화시킬 수 있다.&lt;br /&gt;
(3) activity_main.xml 에서 &lt;fragment&gt; tag로 화면을 채우는데 &lt;strong&gt;이 부분이 각각 생성한 Fragment layout을 inflate하는 부분&lt;/strong&gt;이 될 것이다.&lt;br /&gt;
이 fragment tag안에 속성에서 살펴볼 것은, &lt;strong&gt;defaultNavHost = &quot;true&quot;와 app:navGraph = &quot;@navigation/nav_graph&quot; 인데 두번째 navGraph 속성은 navigation type의 layout에 생성할 layout의 구조를 setting하겠다는 의미, 마지막으로 android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;속성도 필수적으로 설정해주어야 한다.&lt;/strong&gt;&lt;br /&gt;&lt;/fragment&gt;&lt;/p&gt;

&lt;p&gt;(4) 작성한 Fragment layout파일(*.xml)에서 가장 상단 tag의 속성에 &lt;strong&gt;tools:context = “xxxxxFragment” &lt;/strong&gt;라고 지정해주어야 한다.&lt;br /&gt;
이 layout 파일이 어느 fragment 클래스 파일과 관련이 있는지 표시하기 위해서이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;② MainActivity에서는 화면의 fragment 태그에서 fragment 레이아웃을 보여주는 기능만 하므로, 실질적인 Navigation 객체를 만들어서 처리해주는 것은 Fragment class에서 해줄 것이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) onViewCreated() 메소드에서 property로 선언한 NavController 타입의 변수를 초기화시켜준다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    // reference of the view
    navController = Navigation.findNavController(view)
    view_transactions_btn.setOnClickListener(this)
    send_money_btn.setOnClickListener(this)
    view_balance_btn.setOnClickListener(this)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 MainFragment도 nav_graph에 등록된 Fragment이기 때문에 navController객체의 생성이 가능하다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 이제 이 navController를 이용해서 각 버튼의 onClickListener의 이벤트를 구현할 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onClick(v: View?) {
  // backStack관리가 자동으로 이루어지기 때문에 편리하다.
  when(v!!.id){
      R.id.view_transactions_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewTransactionFragment)
      R.id.send_money_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_chooseRecipientFragment)
      R.id.view_balance_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewBalanceFragment)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ②-(1)과 (2)의 과정을 다른 Fragment에서도 작성을 작성해준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;③ 다음 과정에서는 animation, bundle을 추가하는 과정이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Android Kotlin 범위 함수 사용정리</title>
        <description>&lt;p&gt;이번 포스팅에서는 Kotlin 범위 함수 사용에 대해서 정리한다.&lt;br /&gt;
&lt;strong&gt;Kotlin의 표준 라이브러리에는 “범위함수”라는 4가지 기능&lt;/strong&gt;이 있다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;let, with, run, apply&lt;/font&gt;&lt;/strong&gt;이다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;let-&quot;&gt;&lt;strong&gt;.let ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.let{it.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let은 어떤 형태의 확장 기능&lt;/strong&gt;이다.&lt;br /&gt;
위의 예에서는 String 인스턴스를 “hoge”를 it으로 받아 처리하고 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;with-&quot;&gt;&lt;strong&gt;with ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = with(&quot;hoge&quot;){this.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let과 달리 확장함수&lt;/strong&gt;가 없다.&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;run-&quot;&gt;&lt;strong&gt;run ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.run{toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;let 그리고 with이 합쳐진 버전이다.&lt;/strong&gt;&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;
인스턴스를 생성하고 각종 설정을 한 후 실제로 바로 사용하기 위해서 사용된다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;apply-&quot;&gt;&lt;strong&gt;.apply ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;우선 .apply를 사용해서 recyclerView의 LayoutManager와 adapter를 초기해준 아래 예를 같이 살펴보자. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun initRecyclerView(){
    // apply 를 사용해서 layoutManager 와 adapter 를 지정해주었을때,
    recycler_view.apply {
        layoutManager = LinearLayoutManager(this@MainActivity)
        blogAdapter = BlogRecyclerAdapter(context,[dataSet])
        adapter = blogAdapter
    }

    // recycler_view를 지정해주면서 layoutManager 와 adapter 를 지정해주었을때
    recycler_view.layoutManager = LinearLayoutManager(this@MainActivity)
    blogAdapter = BlogRecyclerAdapter(this,[dataSet])
    recycler_view.adapter = blogAdapter
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확실히 apply annotation을 사용해서 recycler_view를 초기화 시켜주면, 매번 recycler_view를 호출해서 사용하지 않아도 가볍게 layoutManager와 adapter 키워드만으로도 초기화 시켜줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Kotlin Singleton Example with MVVM and coroutines</title>
        <description>&lt;h3 id=&quot;kotlin-singleton-example-with-mvvm-and-coroutines&quot;&gt;Kotlin Singleton Example with MVVM and coroutines&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 Post에 정리할 내용은 아래와 같다.&lt;br /&gt;
2 examples :&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) Quick “how to”&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2)Practical example&lt;br /&gt;
-Retrofit&lt;br /&gt;
-Coroutines&lt;br /&gt;
-MVVM&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Singletons&lt;/p&gt;

&lt;p&gt;Instance of an object &lt;br /&gt;
reuse the instance &lt;br /&gt;
Retrofit instance &lt;br /&gt;
Repository instance &lt;br /&gt;
User sessions &lt;br /&gt;
Dagger(Dependency Injection/Provide Singleton)
Dagger라이브러리는 좀 어렵다. 나중에 별도의 강의로 이해하도록 하자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자 이제 실제로 Singleton 패턴의 클래스를 Kotlin으로 작성해보자.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① 우선 models패키지를 작성을 하고, 그 안에 User라는 data class를 작성해준다. &lt;br /&gt;
② 다음으로 ExampleSingleton을 이름으로 하는 Object클래스를 작성한다. 이 클래스 안에는 앞서 작성한 User클래스를 아래와 같이 객체를 만들어준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val singletonUser: User by lazy {
  User(&quot;email@gmail.com&quot;, &quot;username&quot;, &quot;image.png&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;lazy키워드를 사용해서 변수를 위임하면 실제로 해당 속성이 호출되서 사용될때, 초기화가 된다.&lt;br /&gt;
(클래스가 인스턴스화되는 타이밍에는 해당 속성은 메모리상에 초기화되지 않는다) &lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ MainActivity의 onCreate 메소드 내에서 Singleton클래스 내부에서 작성한 singletonUser 변수의 hashCode를 확인해서 실제 화면의 configuration(portrait/landscape)가 변경이 되었을때, 같은 메모리 주소를 반환하고 있는지 확인해본다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;println(&quot;DEBUG: ${ExampleSingleton.singletonUser.hashCode()}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 화면의 configuration을 바꿨을때, 매번 같은 hashCode를 반환함을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 다음으로, api 패키지를 작성하고, MyRetrofitBuilder(Object클래스)와 ApiService 인터페이스를 작성해볼 것이다. &lt;br /&gt;
MyRetrofitBuilder클래스를 Object클래스 타입으로 작성하는 이유는 Kotlin에서는 Object클래스로 작성한다는 의미가 바로 ‘Singleton’으로 작성하겠다는 의미이기 때문이다. ApiService인터페이스에서는 Retrofit을 사용해 통신상으로터 데이터를 취득하는 메소드를 작성할 것이다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;MyRetrofitBuilder.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object MyRetrofitBuilder {

    const val BASE_URL = &quot;https://open-api.xyz/&quot;

    // Singleton Retrofit builder
    val retrofitBuilder: Retrofit.Builder by lazy {
      Retrofit.Builder()
      .baseUrl(BASE_URL)
      .addConverterFactory(GsonConverterFactory.create())
      // 서버로부터 호출되는 데이터의 형식은 JSON형태이므로, 이를 Convert할 Converter가 필요하다.
      // Gson Converter = JSON objcet -&amp;gt; Java object
    }

    // Singleton apiService (Network request)
    val apiService: ApiService by lazy {
      retrofitBuilder
      .build()
      .create(ApiService::class.java)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ApiService.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ApiService {

    @GET(&quot;placeholder/user/{userId}&quot;)
    // 여기서 사용되는 suspend fun은 'coroutine'을 사용하기 위한 fun이다.
    // use 'coroutine' fun return the date from network.
    suspend fun getUser(
        @Path(&quot;userId&quot;) userId: String
    ): User
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;‘suspend fun’을 사용하면 ‘coroutine’을 사용한다는 의미이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑤ &lt;strong&gt;Repository&lt;/strong&gt;패키지 추가하고, Repository Object클래스 작성하기.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Repository{

    var job: CompletableJob? = null

    fun getUser(userId: String): LiveData&amp;lt;User&amp;gt; {
      // job을 초기화시켜준다.
      job = Job()
      return object: LiveData&amp;lt;User&amp;gt;(){
          override fun onActive(){
            super.onActive()
            // 우선 job이 null인지 아닌지 검사를 한다.
            job?.let{ theJob-&amp;gt;
              // job이 null이 아닌경우, 실행을 한다.
              // IO(Dispatchers)+theJob으로 유니크한 CoroutineScope를 background thread에 생성을 한다.
              CoroutineScope(IO+theJob).launch{
                val user = MyRetrofitBuilder.apiService.getUser(userId)
                // live data를 background thread에 해줄 수 없으므로,
                // 우선 MAIN 스레드로 전환을 하고, live data를 setting해주어야 한다.
                withContext(Main){
                  value = user
                  theJob.complete()
                }
              }
            }
          }
      }  
    }
    // job을 calcel하는 method이다.
    fun cancelJob(){
        job?.cancel()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑥ MainViewModel 클래스를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainViewModel : ViewModel() {
    private val _userId: MutableLiveData&amp;lt;String&amp;gt; = MutableLiveData()

    // Transformations _userId에 변화가 생기면 .switchMap 이 trigger 되고 {}안에 코드가 실행된다.
    val user: LiveData&amp;lt;User&amp;gt; = Transformations
          .switchMap(_userId){
              // 기존 _userId에 변화가 생겼으니, 업데이트를 해주어야 한다.
              // 따라서, Repository.getUser를 통해서 새로운 uerId를 취득해서 위에 String변수를 초기화 시켜준다.
              Repository.getUser(it)
          }

    fun setUserId(userId: String){
         val update = userId

         // 현재의 userId가 이미 setting 되었다면 종료한다.
         if(_userId.value == update){
              return
          }
         // 기존의 userId를 update된 새로운 userId로 초기화시킨다.
          _userId.value = update
    }  

    // Repository에서 작성한 cancelJobs() 메소드를 viewModel클래스의 cancelJobs()메소드 안에 작성해준다.
    fun cancelJobs(){
        Repository.cancelJobs()
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑦ MainActivity에서 작성한 MainViewModel클래스의 instance를 작성해서, Observe(변수의 변화가 감지되었을때)를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    lateinit var viewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)

        viewModel.user.observe(this, Observer {user -&amp;gt;
            println(&quot;DBUG: $user&quot;)
        })
        viewModel.setUserId(&quot;1&quot;)
    }

    override fun onDestroy() {
        super.onDestroy()
        viewModel.cancelJobs()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 15 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines0/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines0/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
      <item>
        <title>Kotlin Singleton Example with MVVM and coroutines</title>
        <description>&lt;h3 id=&quot;kotlin-singleton-example-with-mvvm-and-coroutines&quot;&gt;Kotlin Singleton Example with MVVM and coroutines&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 Post에 정리할 내용은 아래와 같다.&lt;br /&gt;
2 examples :&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) Quick “how to”&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2)Practical example&lt;br /&gt;
-Retrofit&lt;br /&gt;
-Coroutines&lt;br /&gt;
-MVVM&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Singletons&lt;/p&gt;

&lt;p&gt;Instance of an object &lt;br /&gt;
reuse the instance &lt;br /&gt;
Retrofit instance &lt;br /&gt;
Repository instance &lt;br /&gt;
User sessions &lt;br /&gt;
Dagger(Dependency Injection/Provide Singleton)
Dagger라이브러리는 좀 어렵다. 나중에 별도의 강의로 이해하도록 하자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자 이제 실제로 Singleton 패턴의 클래스를 Kotlin으로 작성해보자.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① 우선 models패키지를 작성을 하고, 그 안에 User라는 data class를 작성해준다. &lt;br /&gt;
② 다음으로 ExampleSingleton을 이름으로 하는 Object클래스를 작성한다. 이 클래스 안에는 앞서 작성한 User클래스를 아래와 같이 객체를 만들어준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val singletonUser: User by lazy {
  User(&quot;email@gmail.com&quot;, &quot;username&quot;, &quot;image.png&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;lazy키워드를 사용해서 변수를 위임하면 실제로 해당 속성이 호출되서 사용될때, 초기화가 된다.&lt;br /&gt;
(클래스가 인스턴스화되는 타이밍에는 해당 속성은 메모리상에 초기화되지 않는다) &lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ MainActivity의 onCreate 메소드 내에서 Singleton클래스 내부에서 작성한 singletonUser 변수의 hashCode를 확인해서 실제 화면의 configuration(portrait/landscape)가 변경이 되었을때, 같은 메모리 주소를 반환하고 있는지 확인해본다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;println(&quot;DEBUG: ${ExampleSingleton.singletonUser.hashCode()}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 화면의 configuration을 바꿨을때, 매번 같은 hashCode를 반환함을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 다음으로, api 패키지를 작성하고, MyRetrofitBuilder(Object클래스)와 ApiService 인터페이스를 작성해볼 것이다. &lt;br /&gt;
MyRetrofitBuilder클래스를 Object클래스 타입으로 작성하는 이유는 Kotlin에서는 Object클래스로 작성한다는 의미가 바로 ‘Singleton’으로 작성하겠다는 의미이기 때문이다. ApiService인터페이스에서는 Retrofit을 사용해 통신상으로터 데이터를 취득하는 메소드를 작성할 것이다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;MyRetrofitBuilder.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object MyRetrofitBuilder {

    const val BASE_URL = &quot;https://open-api.xyz/&quot;

    // Singleton Retrofit builder
    val retrofitBuilder: Retrofit.Builder by lazy {
      Retrofit.Builder()
      .baseUrl(BASE_URL)
      .addConverterFactory(GsonConverterFactory.create())
      // 서버로부터 호출되는 데이터의 형식은 JSON형태이므로, 이를 Convert할 Converter가 필요하다.
      // Gson Converter = JSON objcet -&amp;gt; Java object
    }

    // Singleton apiService (Network request)
    val apiService: ApiService by lazy {
      retrofitBuilder
      .build()
      .create(ApiService::class.java)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ApiService.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ApiService {

    @GET(&quot;placeholder/user/{userId}&quot;)
    // 여기서 사용되는 suspend fun은 'coroutine'을 사용하기 위한 fun이다.
    // use 'coroutine' fun return the date from network.
    suspend fun getUser(
        @Path(&quot;userId&quot;) userId: String
    ): User
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;‘suspend fun’을 사용하면 ‘coroutine’을 사용한다는 의미이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑤ &lt;strong&gt;Repository&lt;/strong&gt;패키지 추가하고, Repository Object클래스 작성하기.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Repository{

    var job: CompletableJob? = null

    fun getUser(userId: String): LiveData&amp;lt;User&amp;gt; {
      // job을 초기화시켜준다.
      job = Job()
      return object: LiveData&amp;lt;User&amp;gt;(){
          override fun onActive(){
            super.onActive()
            // 우선 job이 null인지 아닌지 검사를 한다.
            job?.let{ theJob-&amp;gt;
              // job이 null이 아닌경우, 실행을 한다.
              // IO(Dispatchers)+theJob으로 유니크한 CoroutineScope를 background thread에 생성을 한다.
              CoroutineScope(IO+theJob).launch{
                val user = MyRetrofitBuilder.apiService.getUser(userId)
                // live data를 background thread에 해줄 수 없으므로,
                // 우선 MAIN 스레드로 전환을 하고, live data를 setting해주어야 한다.
                withContext(Main){
                  value = user
                  theJob.complete()
                }
              }
            }
          }
      }  
    }
    // job을 calcel하는 method이다.
    fun cancelJob(){
        job?.cancel()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑥ MainViewModel 클래스를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainViewModel : ViewModel() {
    private val _userId: MutableLiveData&amp;lt;String&amp;gt; = MutableLiveData()

    // Transformations _userId에 변화가 생기면 .switchMap 이 trigger 되고 {}안에 코드가 실행된다.
    val user: LiveData&amp;lt;User&amp;gt; = Transformations
          .switchMap(_userId){
              // 기존 _userId에 변화가 생겼으니, 업데이트를 해주어야 한다.
              // 따라서, Repository.getUser를 통해서 새로운 uerId를 취득해서 위에 String변수를 초기화 시켜준다.
              Repository.getUser(it)
          }

    fun setUserId(userId: String){
         val update = userId

         // 현재의 userId가 이미 setting 되었다면 종료한다.
         if(_userId.value == update){
              return
          }
         // 기존의 userId를 update된 새로운 userId로 초기화시킨다.
          _userId.value = update
    }  

    // Repository에서 작성한 cancelJobs() 메소드를 viewModel클래스의 cancelJobs()메소드 안에 작성해준다.
    fun cancelJobs(){
        Repository.cancelJobs()
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑦ MainActivity에서 작성한 MainViewModel클래스의 instance를 작성해서, Observe(변수의 변화가 감지되었을때)를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    lateinit var viewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)

        viewModel.user.observe(this, Observer {user -&amp;gt;
            println(&quot;DBUG: $user&quot;)
        })
        viewModel.setUserId(&quot;1&quot;)
    }

    override fun onDestroy() {
        super.onDestroy()
        viewModel.cancelJobs()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 15 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
      <item>
        <title>Transfer data between Activities and Fragments</title>
        <description>&lt;h3 id=&quot;activities와-fragments-사이에서-값-전달하기&quot;&gt;Activities와 Fragments 사이에서 값 전달하기&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① Intent putExtra/getExtra &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② Bundle bundle.putString/bundle.getString &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ Parcelable &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;④ SharedPreference &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Image libraries</title>
        <description>&lt;h3 id=&quot;image-library&quot;&gt;Image Library&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;① Glide library&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) dependencies 추가하기&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Glide library
def glideVersion = '4.11.0'
implementation &quot;com.github.bumptech.glide:glide:$glideVersion&quot;
// Glide v4 uses this new annotation processor
annotationProcessor &quot;com.github.bumptech.glide:compiler:$glideVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) ImageView에 보여줄 이미지를 binding하는 부분에서 아래와 같이 Glide 라이브러리로 바인딩해준다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;[Basic Usage]&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Set the image
RequestOptions defaultOptions = new RequestOptions()
                                .error(R.drawable.ic_launcher_background);
Glide.with(mContext)
            .setDefaultRequestOptions(defaultOptions)
            .load(mNicePlaces.get(position).getImageUrl())
            .into(((Holder)holder).mImage);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Image-Library/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Image-Library/</guid>
        
        
        <category>Android-Libraries</category>
        
      </item>
    
      <item>
        <title>Kotlin &quot;companion object&quot;</title>
        <description>&lt;h3 id=&quot;companion-object-&quot;&gt;&lt;strong&gt;companion object ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Kotlin은 클래스에 static 필드를 갖게 할 수는 없지만, companion object의 구조를 이용해서 Java의 static 메소드와 동일한 동작을 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object {
        const val FREE_PRICE = 0
        fun newFreeBook(title: String) = Book(title, FREE_PRICE)
    }
}

fun main(){
  val book = Book.newFreeBook(&quot;Free Kotlin&quot;)
  println(book)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 companion object 뒤의 {}안에는 일반 클래스의 본체와 같이 구현을 한다. 위와 같이 도우미 개체를 정의하면 Book 클래스 안에 내재 된 싱글 톤 인스턴스(Singleton Instance)가 생성되며, Book.[Field name]형태로 액세스 할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;companion object는 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자체가 클래스 정의를 가지고 있으며, 외부에서 정의 된 클래스의 인스턴스가 아니다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
Book.xxx()라는 접근방식을 보면, 마치 Book 클래스의 싱글톤 인스턴스가 만들어지고 있는 것처럼 보이지만, Book인스턴스가 만들어지는 것은 아니다.&lt;br /&gt;
위의 Book.xxx()라는 문장은 사실 &lt;strong&gt;Book.Companion.xxx()&lt;/strong&gt;이 생략 기법이다. 이 점에서 companion object는 Book 클래스의 인스턴스와는 별개임을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 companion object{}의 형태로 작성할 수 있지만, 이 companion object에 이름을 넣어줄 수도 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object Factory{
      const val FREE_PRICE = 0
      fun freeBook(title: String) = Book(title, FREE_PRICE)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 도우미 객체는 Book.Factory.[Field name] 형태로 액세스 할 수 있다.&lt;br /&gt;
&lt;strong&gt;companion object는 클래스 내에서 하나 밖에 정의할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Android Kotlin Coroutine(비동기 처리)</title>
        <description>&lt;h3 id=&quot;coroutine--&quot;&gt;&lt;strong&gt;Coroutine ?&lt;/strong&gt; &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘Coroutine’에 대해 알아보기 전에 우선, ‘동기’와 ‘비동기’의 개념에 대해서 알아보자.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;동기(Synchronous) : will run in the same thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex1) 메인 스레드에서 실행&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 메인 스레드에서 실행
fun runMain(){
  val data = Weather.tomorrow()
  println(&quot;Tomorrow weather : ${data}&quot;)
}

fun Weather.tomorrow() : String{
  Thread.sleep(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;비동기(Asynchronous) : will run in a different thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex2) Coroutine으로 비동기 스레드 처리&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun runMain() : Job = viewModelScope.launch{
    val data = Weather.tomorrow()
    println(&quot;Tomorrow weather : ${data}&quot;)
}

suspend fun Weather.tomorrow() : String{
  delay(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ‘ex1’의 코드에서는 모두 Main Thread에서 실행하는 소스코드이다. 이는 동기적으로 호출해서 사용되고 있는 예이다.&lt;br /&gt;
동기적 처리는 2초 스레드가 차단되어버리는 문제가 있다. 이 스레드가 차단되는 동안에는 사용자의 조작이 얼어 버리기 때문에 응용 프로그램에서 이 코드를 작성하는 것은 현실적이지 않다. 한편 coroutin을 사용하면 결과가 나올 때까지 2초 사용자가 일반적으로 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 차이가 나는 이유는 &lt;strong&gt;coroutine에서 스레드를 차단하는 대신 처리를 &lt;font color=&quot;Red&quot;&gt;&quot;중단&quot;&lt;/font&gt;하기 때문이다.&lt;/strong&gt;&lt;br /&gt;
첫번째 소스 코드에서 Thread.sleep() 따라 2초 main thread를 점유(차단)하고, 그 동안 다른 작업을 하고 싶어도 메인 스레드가 사용할 수 없다. &lt;br /&gt;
한편 coroutine의 예에서 사용한 delay()함수는 2초간 차단하는 것이 아니라 &lt;strong&gt;main thread를 2초 동안 방출&lt;/strong&gt;하고  main thread를 다시 취득하고 처리를 계속한다. main thread가 개방되는 동안 다른 process에 thread를 활용할 수 있다. 이것을&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;&quot;중단(suspend)&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 ‘ex2’의 코드에서 delay() 같은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;중단이 발생하는 함수를 &quot;suspend 함수&quot;라 한다.&lt;/font&gt;&lt;/strong&gt; 일반 함수는 중단하지 않기 때문에, suspend 함수를 호출할 수 없다. &lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※suspend 함수를 호출하려면 launch에서 호출하거나 함수에 suspend 키워드를 붙여서 suspend fun을 호출해야 한다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;※ 이처럼 coroutine은 기본적으로 사용이 어렵지 않다. 기본적으로 &lt;font color=&quot;Red&quot;&gt;&quot;launch()&quot;&lt;/font&gt;에서 비동기 작업을 시작하고, &lt;font color=&quot;Red&quot;&gt;중단함수(launch{}내에서 실행할 함수)는 suspend로 선언해서 사용&lt;/font&gt;한다.&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;coroutinescope-&quot;&gt;&lt;strong&gt;CoroutineScope ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘ex2’ 예제 코드를 살펴보면 viewModelScope에 대한 launch{…}　호출로, &lt;strong&gt;coroutine을 시작하는 기능을 가진 개체를 &lt;font color=&quot;Red&quot;&gt;&quot;CoroutineScope&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 ‘CoroutineScope’는 coroutine의 &lt;strong&gt;시작뿐만 아니라 시작한 coroutine을 적절하게 종료하는 역할을 담당하고 있다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 Android KTX로 제공되는 &lt;strong&gt;“viewModelScope”&lt;/strong&gt;를 닫을때 coroutine을 자동으로 취소해준다.&lt;br /&gt;
Android에서 사용자 조작에 의한 처리를 하는 경우, “viewModelScope”에서 시작하는 것이 좋다. 병렬 프로그래밍을 하는데 있어 간과하기 쉬운 취소 처리도 CoroutineScope가 제대로 해줄 수 있게 되어있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val  job  =  runMain ()
// 개별적으로 작업을 취소한다.  
job . cancel ()

runMain ()

// viewModelScope를 cancel()하게 되면, viewModelScope에서 실행 한 작업을 모두 취소 할 수 있다.
viewModelScope . cancel ()  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;launch-내에서-호출해서-사용할-suspend-함수를-작성하는-방법에-대해-알아보자&quot;&gt;&lt;strong&gt;launch{} 내에서 호출해서 사용할 suspend 함수를 작성하는 방법에 대해 알아보자.&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① 블록처리를 suspend 함수로 변환&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow():String = withContext(Dispatchers.IO){
    Thread.sleep(2000)
    &quot;Text&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;→ &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;withContext(Dispatchers.IO){...}&lt;/font&gt;&lt;/strong&gt;에서 다른 스레드를 사용하여 실행하고, withContext() 처리가 완료되기 전까지 메인 스레드를 개방할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② 콜백함수를 suspend 함수로 변환&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun Weather.tomorrow(callback : (String) -&amp;gt; Unit) : Unit {
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({callback(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCoroutine{...}를 사용해서 suspend함수로 변환&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weathers.tomorrow() : String = suspendCoroutine{ c -&amp;gt;
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({c.resume(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCancellableCoroutine{...}를 사용해서 suspend함수로 변환하는 것을 추천&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow() : String = suspendCancellableCoroutine{ c -&amp;gt;
  // cancel 대응을 위한 코드 ① : 콜백 처리를 위한 변수
  val callback = Runnable {
      // 취소 대응을 위한 코드 ②
      if(c.isActive) c.resume(&quot;Text&quot;)
  }

  val handler = Handler()
  // cancel 대응을 위한 코드 ③ : coroutine 취소가 일어 났을 때 Handler 측도 취소한다.
  c.invokeOnCancellation{handler.removeCallbacks(callback)}

  // 2 초후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그 동안 스레드가 해제된다.
  handler.postDelayed(callback, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://qiita.com/wm3/items/48b5b5c878561ff4761a&quot;&gt;https://qiita.com/wm3/items/48b5b5c878561ff4761a&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Android Kotlin Coroutine Basic</title>
        <description>&lt;h3 id=&quot;coroutine--&quot;&gt;&lt;strong&gt;Coroutine ?&lt;/strong&gt; &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Work with Background thread &lt;br /&gt;
Coroutine은 AsyncTask 와 같이 Threading하는 방법 중에 하나이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android/2020-04-16 coroutine thread.png&quot; alt=&quot;blog capture&quot; title=&quot;capture img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ 아래와 같은 상황에서 Coroutine은 유용하게 쓰인다.&lt;/strong&gt;&lt;br /&gt;
① Request to network retrofit volley 등의 통신 라이브러리를 사용할때, Main Thread가 Block된다.&lt;br /&gt;
② Accessing the internal SQLite database on the phone. ex) Room database&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;위의 두가지 경우에서 일반적으로 background thread가 사용이 된다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;simulate network request and internal room database.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;Sequence&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
(1) Get the result value from background thread.&lt;br /&gt;
(2) Take the result and then display on the main thread.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Android 개발을 하다보면 Network나 내부 데이터베이스로부터 데이터를 취득해서 순차적으로 취득한 데이터를 처리해야 되는 경우가 있다. &lt;br /&gt;
이런 경우는 이미 경험을 해봤었기 때문에 얼마나 큰 문제인지 알고 있다. 이 문제를 해결하기 위해서는 RxJava나 callback함수를 사용해서 작성을 하면, 코드가 매우 복잡해지기 때문에, Coroutine을 사용해서 작성을 하면 Simple하게 코드를 작성할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① Gradle에 Coroutine과 관련된 dependencies를 추가한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def coroutines_version = &quot;1.2.1&quot;
implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version&quot;
implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;② debug용으로 log를 확인하기 위해 “logThread” 메소드를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun logThread(methodName: String){
    println(&quot;debug: ${methodName}: ${Thread.currentThread().name}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;③ 테스트용으로 Api로부터 결과값을 가져오는 메소드(suspend)를 두개 작성한다. 이는 순차적으로 취득하는 데이터를 최종적으로 Main thread의 UI요소에 반영하기 위함이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun getResult1FromApi():String{
    logThread(&quot;getResult1FromApi&quot;)
    delay(1000) // sleep single coroutine
    //Thread.sleep(1000) // sleep all coroutine
    return RESULT_1 // &quot;Result #1&quot;
}

private suspend fun getResult2FromApi(): String{
    logThread(&quot;getResult2FromApi&quot;)
    delay(1000)
    return RESULT_2 // &quot;Result #2&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 위에서 작성한 Api취득 메소드를 fakeApiResult() 메소드(suspend) 내에서 처리하도록 작성한다. &lt;br /&gt;
   여기서 테스트해볼 것은 api로부터 취득한 값을 UI상에 표시하는 테스트를 해볼 것이다. 하지만 &lt;strong&gt;현재 fakeApiResult()메소드가 실행되는 thread는 Main thread가 아닌 Background thread&lt;/strong&gt;이므로, &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;UI에서 처리하기 위해서는 취득한 값을 &quot;Main thread&quot;로 보내서 UI에 표시처리해야 한다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun fakeApiResult(){
    val result1 = getResult1FromApi()
    println(&quot;debug: $result1&quot;)
    setTextOnMainThread(result1)

    // result1 부분이 처리된 후에 result2부분이 순차적으로 실행될 것이다.
    val result2 = getResult2FromApi()
    setTextOnMainThread(result2)
    //text.setText(result1) //이 작업은 crash 될 것이다.
    // 그 이유는 background thread 에서 작업을 하고 있고,
    // 실제 UI와 interact 하고 있는 thread 는 Main thread 이기 때문이다.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;setTextOnMainThread() 메소드 (Main thread로 thread를 전환하여 취득한 결과 값을 UI반영하기)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun setTextOnMainThread(input: String){
    //CoroutineScope(Main)로 하거나
    withContext(Main){
      setNewText(input)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;UI 상에 있는 TextView에 text를 setting하는 메소드&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun setNewText(input: String){
    val newText = text.text.toString() + &quot;\n$input&quot;
    text.text = newText
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑤ 마지막으로 onCreate()메소드에 작성한 코드를 살펴보자. 이 코드에서 주목해야 될 부분은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;&quot;CoroutineScope&quot;&lt;/font&gt;&lt;/strong&gt;이다. CoroutineScope의 option으로는 &lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;IO, Main, Default&lt;/font&gt;&lt;/strong&gt;가 있다. 각 option은 다른 Thread 기능을 하는데, &lt;strong&gt;IO(Input/Output) thread의 경우, Network, local database interaction 기능&lt;/strong&gt;을 하며, &lt;strong&gt;Main thread&lt;/strong&gt;의 경우, UI 요소와 상호작용하는 역할을 한다. 이외에 Default option은 heavy competition work를 다룰때 사용한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)

      button.setOnClickListener{
          // IO(Network, local database interaction),
          // Main(Main thread, interact with UI),
          // Default(heavy competition work)
          CoroutineScope(IO).launch {
              //launch (coroutine builder)
              fakeApiResult()
          }
      }
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0&quot;&gt;Android coroutines codelab&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine-basic/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine-basic/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>MVVM Architecture Image Training</title>
        <description>&lt;h2 id=&quot;mvvm-architecture&quot;&gt;MVVM Architecture&lt;br /&gt;&lt;/h2&gt;

&lt;h3 id=&quot;java-&quot;&gt;Java &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;① ViewModel Class&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) class 선언하기&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivityViewModel extends ViewModel {

    private MutableLiveData&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt; mNicePlaces;

    public LiveData&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt; getNicePlaces(){return mNicePlaces;}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스를 선언할때에는 ViewModel 클래스를 상속하고, field변수로 MutableLiveData&amp;lt;List&lt;NicePlace&gt;&amp;gt;타입의 변수를 선언해준다. Field변수로 선언을 해줄때는 값이 변화하기 때문에 MutableLiveData 타입으로 선언하지만, 이 값을 읽어올때는 LiveData&amp;lt;List&lt;NicePlace&gt;&amp;gt; 타입으로 선언해준다. &lt;br /&gt;&lt;/NicePlace&gt;&lt;/NicePlace&gt;&lt;/p&gt;

&lt;p&gt;(2) MainActivity에서 작성한 MainActivityViewModel 인스턴스를 만들어서 초기화시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mMainActivityViewModel = ViewModelProviders.of(this).get(MainActivityViewModel.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;우선, dependencies에 Lifecycle components dependency를 넣어준다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Lifecycle components
def archLifecycleVersion = '1.1.1'
implementation &quot;android.arch.lifecycle:extensions:$archLifecycleVersion&quot;
annotationProcessor &quot;android.arch.lifecycle:compiler:$archLifecycleVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음으로 해줄 것은 &lt;strong&gt;데이터가 변화하는 것을 관찰하기 위한 설정&lt;/strong&gt;을 할 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mMainActivityViewModel.getNicePlaces().observe(this, new Observer&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt;() {
    @Override
    public void onChanged(List&amp;lt;NicePlace&amp;gt; nicePlaces) {
        mNicePlaceRecycleAdapter.notifyDataSetChanged();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이젠 데이터가 변할때마다 변화된 데이터를 화면에 잘 출력할 수 있도록 adapter를 초기화시켜줄때 이 변화된 데이터로 초기화를 시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void initRecyclerView(){
  mAdapter = new RecyclerAdapter(this, mMainActivityViewModel.getNicePlaces().getValue());
  RecyclerView.LayoutManager linearLayoutManager = new LinearLayoutManager(this);
  mRecyclerView.setLayoutManager(linearLayoutManager);
  mRecyclerView.setAdapter(mAdapter);
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(3) Repository 클래스를 작성해준다.&lt;br /&gt;
    이 Repository클래스에서는 실제 화면에 보여지는 Data의 setter와 getter메소드가 있는 클래스이다.&lt;br /&gt;
    Repository class는 Singleton으로 작성을 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(4) 작성한 Repository 클래스를 활용하여, ViewModel 클래스에서 init() 메소드를 작성해준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void init(){
  if(mNicePlaces != null){
      return;
  }
  mRepo = NicePlaceRepository.getInstance();
  mNicePlaces = mRepo.getNicePlaces();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 작성한 init() 메소드는 MainActivity에서 ViewModel 클래스를 초기화시켜줄때, 기존의 dataSet변수가 ‘null’인 경우, ViewModel 클래스 객체를 초기화시켜준 다음에 Repository로부터 데이터를 가져와서 데이터를 초기화시켜주는 작업을 한다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kotlin-&quot;&gt;Kotlin &lt;br /&gt;&lt;/h3&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/MVVM-Architecture-Image-Training/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/MVVM-Architecture-Image-Training/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
  </channel>
</rss>
