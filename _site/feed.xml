<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lee Hyungi's Tech Blog</title>
    <description>Hyungi's Ideas &amp; Blogs</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 18 Apr 2020 18:26:21 +0900</pubDate>
    <lastBuildDate>Sat, 18 Apr 2020 18:26:21 +0900</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Android-To Do App for AAD Exam.</title>
        <description>&lt;h3 id=&quot;to-do-app-for-aad-exam&quot;&gt;To Do App for AAD Exam&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① MVVM Architecture &lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/18/To_Do_App_for_AAD_exam/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/18/To_Do_App_for_AAD_exam/</guid>
        
        
        <category>Android-AAD</category>
        
      </item>
    
      <item>
        <title>Android Core</title>
        <description>&lt;h3 id=&quot;android-core&quot;&gt;Android Core&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① Android Core &lt;br /&gt;&lt;br /&gt;
첫번째 항목으로 &lt;strong&gt;안드로이드 코어&lt;/strong&gt;에 대해서 알아보자. &lt;br /&gt;&lt;br /&gt;
안드로이드는 Linux 기반 운영 체제로 주로 모바일 장치용으로 설계되어있다. Android 어플리케이션은 멀티 태스킹이 가능하며 Java, Kotlin 또는 C++로 작성이 되어 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;AAD 인증 시험을 위해서 Android 개발자는 아래의 체크리스트 내용을 수행해야 한다. &lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) Android 시스템의 아키텍처에 대한 이해할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) Android 앱의 기본 빌딩 블록을 설명할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(3) Android 앱을 빌드하고 실행하는 방법을 알 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(4) &lt;code class=&quot;highlighter-rouge&quot;&gt;Toast&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Snackbar&lt;/code&gt;를 사용하여 간단한 메시지를 팝업으로 표시할 수 있다.&lt;br /&gt;
안드로이드 developer : &lt;a href=&quot;https://developer.android.com/guide/topics/ui/notifiers/toasts&quot;&gt;https://developer.android.com/guide/topics/ui/notifiers/toasts&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(5) 앱 UI 외부에서 메시지를 표시할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Notifications&lt;/code&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(6) 앱을 로컬화하는 방법에 대해 이해할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(7) &lt;code class=&quot;highlighter-rouge&quot;&gt;JobScheduler&lt;/code&gt;를 사용하여 백그라운드 작업을 예약할 수 있다.&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/18/Android-Core/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/18/Android-Core/</guid>
        
        
        <category>Android-AAD</category>
        
      </item>
    
      <item>
        <title>Android AAD 시험 체크리스트</title>
        <description>&lt;h3 id=&quot;aad-시험-학습가이드-google-associate-android-developer-certification-exam&quot;&gt;AAD 시험 학습가이드 (Google Associate Android Developer Certification exam)&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://developers.google.com/certification/associate-android-developer/study-guide&quot;&gt;https://developers.google.com/certification/associate-android-developer/study-guide&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참고(Github/associate-android-developer-exam) : &lt;a href=&quot;https://github.com/topics/associate-android-developer-exam&quot;&gt;https://github.com/topics/associate-android-developer-exam&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;이번 포스팅에서는 안드로이드 공부를 위한 가이드라인의 일환으로 AAD 시험을 위한 체크리스트를 작성해본다.&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시험 할 역량 영역과 개별 역량리스트를 기준으로 작성한다. &lt;br /&gt;&lt;br /&gt;
시험의 테스트 항목은 아래와 같이 총 5개의 항목으로 구성된다. &lt;br /&gt;&lt;br /&gt;
① Android Core &lt;br /&gt;&lt;br /&gt;
② User Interface &lt;br /&gt;&lt;br /&gt;
③ Database Management &lt;br /&gt;&lt;br /&gt;
④ Debugging &lt;br /&gt;&lt;br /&gt;
⑤ Testing &lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/18/Android-AAD-exam-checklist/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/18/Android-AAD-exam-checklist/</guid>
        
        
        <category>Android-AAD</category>
        
      </item>
    
      <item>
        <title>Android Jetpack Navigation Component</title>
        <description>&lt;h3 id=&quot;android-jetpack-navigation-component&quot;&gt;Android Jetpack Navigation Component&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 포스팅에서는 Jetpack Navigation Component를 활용하여 Fragment간의 전이 처리하는 것에 대해서 배워 볼 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;① app gradle에 dependencies 추가하기&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def nav_version = &quot;2.3.0-alpha05&quot;
// Kotlin
implementation &quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;
implementation &quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;

def material_version = &quot;1.2.0-alpha05&quot;
implementation &quot;com.google.android.material:material:$material_version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;※ navigation graph 기능&lt;/p&gt;

&lt;p&gt;(1) resouce - [New Resource File] - (File name : nav_graph / Resource type : Navigation)&lt;br /&gt;
(2) 위의 nav_graph 파일에 화면에 보여질 UI의 화면 설계구조를 구조화시킬 수 있다.&lt;br /&gt;
(3) activity_main.xml 에서 &lt;fragment&gt; tag로 화면을 채우는데 &lt;strong&gt;이 부분이 각각 생성한 Fragment layout을 inflate하는 부분&lt;/strong&gt;이 될 것이다.&lt;br /&gt;
이 fragment tag안에 속성에서 살펴볼 것은, &lt;strong&gt;defaultNavHost = &quot;true&quot;와 app:navGraph = &quot;@navigation/nav_graph&quot; 인데 두번째 navGraph 속성은 navigation type의 layout에 생성할 layout의 구조를 setting하겠다는 의미, 마지막으로 android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;속성도 필수적으로 설정해주어야 한다.&lt;/strong&gt;&lt;br /&gt;&lt;/fragment&gt;&lt;/p&gt;

&lt;p&gt;(4) 작성한 Fragment layout파일(*.xml)에서 가장 상단 tag의 속성에 &lt;strong&gt;tools:context = “xxxxxFragment” &lt;/strong&gt;라고 지정해주어야 한다.&lt;br /&gt;
이 layout 파일이 어느 fragment 클래스 파일과 관련이 있는지 표시하기 위해서이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;② MainActivity에서는 화면의 fragment 태그에서 fragment 레이아웃을 보여주는 기능만 하므로, 실질적인 Navigation 객체를 만들어서 처리해주는 것은 Fragment class에서 해줄 것이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) onViewCreated() 메소드에서 property로 선언한 NavController 타입의 변수를 초기화시켜준다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    // reference of the view
    navController = Navigation.findNavController(view)
    view_transactions_btn.setOnClickListener(this)
    send_money_btn.setOnClickListener(this)
    view_balance_btn.setOnClickListener(this)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 MainFragment도 nav_graph에 등록된 Fragment이기 때문에 navController객체의 생성이 가능하다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 이제 이 navController를 이용해서 각 버튼의 onClickListener의 이벤트를 구현할 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onClick(v: View?) {
  // backStack관리가 자동으로 이루어지기 때문에 편리하다.
  when(v!!.id){
      R.id.view_transactions_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewTransactionFragment)
      R.id.send_money_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_chooseRecipientFragment)
      R.id.view_balance_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewBalanceFragment)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ②-(1)과 (2)의 과정을 다른 Fragment에서도 작성을 작성해준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;③ 다음 과정에서는 animation, bundle을 추가하는 과정이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;....
&amp;lt;fragment
    android:id=&quot;@+id/mainFragment&quot;
    android:name=&quot;com.hyungilee.androidjetpacknavigationsample.MainFragment&quot;
    android:label=&quot;fragment_main&quot;
    tools:layout=&quot;@layout/fragment_main&quot; &amp;gt;
      &amp;lt;action
        android:id=&quot;@+id/action_mainFragment_to_chooseRecipientFragment&quot;
        app:destination=&quot;@id/chooseRecipientFragment&quot;
        app:popEnterAnim=&quot;@anim/slide_in_left&quot;
        app:popExitAnim=&quot;@anim/slide_out_right&quot;
        app:enterAnim=&quot;@anim/slide_in_right&quot;
        app:exitAnim=&quot;@anim/slide_out_left&quot;
        app:popUpTo=&quot;@id/mainFragment&quot;
        app:popUpToInclusive=&quot;true&quot;/&amp;gt;
 ....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;backStack이나 Back버튼을 눌렀을때 적용되는 animation효과는 popExitAnim 속성이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 어플을 제작할때 생각해봐야 하는 부분은 대부분의 어플에 있는 Login 기능이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;로그인이 성공한 뒤에 Back 버튼을 누르게 되면, 이전의 로그인 화면으로 돌아가는 것이 아닌 어플자체가 화면에서 사라지고 단말기의 Background가 표시됨을 알 수 있다. (로그인 완료된 후에 Back버튼을 누른다고 다시 로그인 화면으로 돌아가는 것은 non sense상황)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 이벤트 처리 동작에 대해서 생각해보자.&lt;br /&gt;
Back버튼을 누른다고 이전화면으로 돌아가지 않고, BackStack에서 실행되는 Task들을 모두 종료시키는 것을 해보자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;popUpTo and popUpToInclusive&lt;/strong&gt;&lt;br /&gt;
① popUpTo : Back 버튼을 눌렀을때 이벤트　&lt;br /&gt;
② popUpToInclusive : true(clear everything to navigate) or false(leave it) &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ Android 공식 : &lt;/strong&gt;&lt;a href=&quot;https://developer.android.com/guide/navigation/navigation-getting-started&quot;&gt;Get started with the Navigation component&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;Fragment 간에 값을 보내기&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) 먼저 아래 sample 코드를 보고 nav_graph.xml에서의 설정에 대해서 이해해보도록 하자. &lt;br /&gt;
우선 화면은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;specifyAmountFragment.xml -&amp;gt; confirmationFragment.xml&lt;/font&gt;&lt;/strong&gt;전이를 하게 되는데, 화면전이가 일어날때 값을 bundle의 형태로 넘겨준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;보내고자하는 데이터를 입력하는 Fragment 태그에서 name이 recipient, defaultValue가 None으로 된 태그를 추가해주고, &lt;br /&gt;
받는 Fragment 태그에서도 똑같이 argument태그를 추가해주고, 추가적으로 name이 “amount”, argument 타입이 보내고자하는 데이터의 data class의 경로를 지정해준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;....
&amp;lt;fragment
    android:id=&quot;@+id/confirmationFragment&quot;
    android:name=&quot;com.hyungilee.androidjetpacknavigationsample.ConfirmationFragment&quot;
    android:label=&quot;fragment_confirmation&quot;
    tools:layout=&quot;@layout/fragment_confirmation&quot;&amp;gt;

    &amp;lt;argument android:name=&quot;recipient&quot;
              android:defaultValue=&quot;None&quot;/&amp;gt;

    &amp;lt;argument android:name=&quot;amount&quot;
              app:argType=&quot;com.hyungilee.androidjetpacknavigationsample.Money&quot;/&amp;gt;

&amp;lt;/fragment&amp;gt;

&amp;lt;fragment
    android:id=&quot;@+id/specifyAmountFragment&quot;
    android:name=&quot;com.hyungilee.androidjetpacknavigationsample.SpecifyAmountFragment&quot;
    android:label=&quot;fragment_specify_amount&quot;
    tools:layout=&quot;@layout/fragment_specify_amount&quot; &amp;gt;

    &amp;lt;argument android:name=&quot;recipient&quot;
              android:defaultValue=&quot;None&quot;/&amp;gt;
....              
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) 다음으로 수취인 이름을 등록하는 Fragment(chooseRecipientFragment.kt)파일에서 아래와 같이 bundle의 형태로 수취인 데이터를 넘겨준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R.id.next_btn -&amp;gt; {
      if(!TextUtils.isEmpty(input_recipient.text.toString())){
          val bundle = bundleOf(&quot;recipient&quot; to input_recipient.text.toString())

          navController.navigate(
              R.id.action_chooseRecipientFragment_to_specifyAmountFragment,
              bundle
          )
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(3) 데이터를 받는 Fragment(SpecifyAmountFragment.kt)파일에서는 아래와 같이 bundle 형태로 데이터를 취득하는 부분을 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lateinit var recipient: String

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    recipient = arguments?.getString(&quot;recipient&quot;)!!
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Parcelable 데이터를 받는 경우에는 getParcelable(“[키값]”) 로 해서 취득하며, Parcelable로 취득할 객체의 class는 아래와 같이 작성해준다. 여기서 값의 초기화는 “onCreater()”메소드에서 처리하며, 화면에 보여질 view의 초기화는 메소드명대로 “onViewCreated()”메소드에서 처리해준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Parcelize
data class Money(val amount: BigDecimal): Parcelable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Android Kotlin 범위 함수 사용정리</title>
        <description>&lt;p&gt;이번 포스팅에서는 Kotlin 범위 함수 사용에 대해서 정리한다.&lt;br /&gt;
&lt;strong&gt;Kotlin의 표준 라이브러리에는 “범위함수”라는 4가지 기능&lt;/strong&gt;이 있다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;let, with, run, apply&lt;/font&gt;&lt;/strong&gt;이다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;let-&quot;&gt;&lt;strong&gt;.let ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.let{it.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let은 어떤 형태의 확장 기능&lt;/strong&gt;이다.&lt;br /&gt;
위의 예에서는 String 인스턴스를 “hoge”를 it으로 받아 처리하고 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;with-&quot;&gt;&lt;strong&gt;with ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = with(&quot;hoge&quot;){this.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let과 달리 확장함수&lt;/strong&gt;가 없다.&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;run-&quot;&gt;&lt;strong&gt;run ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.run{toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;let 그리고 with이 합쳐진 버전이다.&lt;/strong&gt;&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;
인스턴스를 생성하고 각종 설정을 한 후 실제로 바로 사용하기 위해서 사용된다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;apply-&quot;&gt;&lt;strong&gt;.apply ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;우선 .apply를 사용해서 recyclerView의 LayoutManager와 adapter를 초기해준 아래 예를 같이 살펴보자. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun initRecyclerView(){
    // apply 를 사용해서 layoutManager 와 adapter 를 지정해주었을때,
    recycler_view.apply {
        layoutManager = LinearLayoutManager(this@MainActivity)
        blogAdapter = BlogRecyclerAdapter(context,[dataSet])
        adapter = blogAdapter
    }

    // recycler_view를 지정해주면서 layoutManager 와 adapter 를 지정해주었을때
    recycler_view.layoutManager = LinearLayoutManager(this@MainActivity)
    blogAdapter = BlogRecyclerAdapter(this,[dataSet])
    recycler_view.adapter = blogAdapter
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확실히 apply annotation을 사용해서 recycler_view를 초기화 시켜주면, 매번 recycler_view를 호출해서 사용하지 않아도 가볍게 layoutManager와 adapter 키워드만으로도 초기화 시켜줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Kotlin Singleton Example with MVVM and coroutines</title>
        <description>&lt;h3 id=&quot;kotlin-singleton-example-with-mvvm-and-coroutines&quot;&gt;Kotlin Singleton Example with MVVM and coroutines&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 Post에 정리할 내용은 아래와 같다.&lt;br /&gt;
2 examples :&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) Quick “how to”&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2)Practical example&lt;br /&gt;
-Retrofit&lt;br /&gt;
-Coroutines&lt;br /&gt;
-MVVM&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Singletons&lt;/p&gt;

&lt;p&gt;Instance of an object &lt;br /&gt;
reuse the instance &lt;br /&gt;
Retrofit instance &lt;br /&gt;
Repository instance &lt;br /&gt;
User sessions &lt;br /&gt;
Dagger(Dependency Injection/Provide Singleton)
Dagger라이브러리는 좀 어렵다. 나중에 별도의 강의로 이해하도록 하자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자 이제 실제로 Singleton 패턴의 클래스를 Kotlin으로 작성해보자.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① 우선 models패키지를 작성을 하고, 그 안에 User라는 data class를 작성해준다. &lt;br /&gt;
② 다음으로 ExampleSingleton을 이름으로 하는 Object클래스를 작성한다. 이 클래스 안에는 앞서 작성한 User클래스를 아래와 같이 객체를 만들어준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val singletonUser: User by lazy {
  User(&quot;email@gmail.com&quot;, &quot;username&quot;, &quot;image.png&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;lazy키워드를 사용해서 변수를 위임하면 실제로 해당 속성이 호출되서 사용될때, 초기화가 된다.&lt;br /&gt;
(클래스가 인스턴스화되는 타이밍에는 해당 속성은 메모리상에 초기화되지 않는다) &lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ MainActivity의 onCreate 메소드 내에서 Singleton클래스 내부에서 작성한 singletonUser 변수의 hashCode를 확인해서 실제 화면의 configuration(portrait/landscape)가 변경이 되었을때, 같은 메모리 주소를 반환하고 있는지 확인해본다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;println(&quot;DEBUG: ${ExampleSingleton.singletonUser.hashCode()}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 화면의 configuration을 바꿨을때, 매번 같은 hashCode를 반환함을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 다음으로, api 패키지를 작성하고, MyRetrofitBuilder(Object클래스)와 ApiService 인터페이스를 작성해볼 것이다. &lt;br /&gt;
MyRetrofitBuilder클래스를 Object클래스 타입으로 작성하는 이유는 Kotlin에서는 Object클래스로 작성한다는 의미가 바로 ‘Singleton’으로 작성하겠다는 의미이기 때문이다. ApiService인터페이스에서는 Retrofit을 사용해 통신상으로터 데이터를 취득하는 메소드를 작성할 것이다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;MyRetrofitBuilder.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object MyRetrofitBuilder {

    const val BASE_URL = &quot;https://open-api.xyz/&quot;

    // Singleton Retrofit builder
    val retrofitBuilder: Retrofit.Builder by lazy {
      Retrofit.Builder()
      .baseUrl(BASE_URL)
      .addConverterFactory(GsonConverterFactory.create())
      // 서버로부터 호출되는 데이터의 형식은 JSON형태이므로, 이를 Convert할 Converter가 필요하다.
      // Gson Converter = JSON objcet -&amp;gt; Java object
    }

    // Singleton apiService (Network request)
    val apiService: ApiService by lazy {
      retrofitBuilder
      .build()
      .create(ApiService::class.java)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ApiService.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ApiService {

    @GET(&quot;placeholder/user/{userId}&quot;)
    // 여기서 사용되는 suspend fun은 'coroutine'을 사용하기 위한 fun이다.
    // use 'coroutine' fun return the date from network.
    suspend fun getUser(
        @Path(&quot;userId&quot;) userId: String
    ): User
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;‘suspend fun’을 사용하면 ‘coroutine’을 사용한다는 의미이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑤ &lt;strong&gt;Repository&lt;/strong&gt;패키지 추가하고, Repository Object클래스 작성하기.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Repository{

    var job: CompletableJob? = null

    fun getUser(userId: String): LiveData&amp;lt;User&amp;gt; {
      // job을 초기화시켜준다.
      job = Job()
      return object: LiveData&amp;lt;User&amp;gt;(){
          override fun onActive(){
            super.onActive()
            // 우선 job이 null인지 아닌지 검사를 한다.
            job?.let{ theJob-&amp;gt;
              // job이 null이 아닌경우, 실행을 한다.
              // IO(Dispatchers)+theJob으로 유니크한 CoroutineScope를 background thread에 생성을 한다.
              CoroutineScope(IO+theJob).launch{
                val user = MyRetrofitBuilder.apiService.getUser(userId)
                // live data를 background thread에 해줄 수 없으므로,
                // 우선 MAIN 스레드로 전환을 하고, live data를 setting해주어야 한다.
                withContext(Main){
                  value = user
                  theJob.complete()
                }
              }
            }
          }
      }  
    }
    // job을 calcel하는 method이다.
    fun cancelJob(){
        job?.cancel()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑥ MainViewModel 클래스를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainViewModel : ViewModel() {
    private val _userId: MutableLiveData&amp;lt;String&amp;gt; = MutableLiveData()

    // Transformations _userId에 변화가 생기면 .switchMap 이 trigger 되고 {}안에 코드가 실행된다.
    val user: LiveData&amp;lt;User&amp;gt; = Transformations
          .switchMap(_userId){
              // 기존 _userId에 변화가 생겼으니, 업데이트를 해주어야 한다.
              // 따라서, Repository.getUser를 통해서 새로운 uerId를 취득해서 위에 String변수를 초기화 시켜준다.
              Repository.getUser(it)
          }

    fun setUserId(userId: String){
         val update = userId

         // 현재의 userId가 이미 setting 되었다면 종료한다.
         if(_userId.value == update){
              return
          }
         // 기존의 userId를 update된 새로운 userId로 초기화시킨다.
          _userId.value = update
    }  

    // Repository에서 작성한 cancelJobs() 메소드를 viewModel클래스의 cancelJobs()메소드 안에 작성해준다.
    fun cancelJobs(){
        Repository.cancelJobs()
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑦ MainActivity에서 작성한 MainViewModel클래스의 instance를 작성해서, Observe(변수의 변화가 감지되었을때)를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    lateinit var viewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)

        viewModel.user.observe(this, Observer {user -&amp;gt;
            println(&quot;DBUG: $user&quot;)
        })
        viewModel.setUserId(&quot;1&quot;)
    }

    override fun onDestroy() {
        super.onDestroy()
        viewModel.cancelJobs()
    }
} &amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;※ 노트필기 캡쳐 &lt;br /&gt;
&lt;img src=&quot;/images/android/MVVM Kotlin note.png&quot; alt=&quot;blog capture&quot; title=&quot;capture img&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;※ 실습했던 Repository : &lt;a href=&quot;https://github.com/MikeHyungiLee/MVVMArchitectureKotlin&quot;&gt;https://github.com/MikeHyungiLee/MVVMArchitectureKotlin&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 15 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
      <item>
        <title>Transfer data between Activities and Fragments</title>
        <description>&lt;h3 id=&quot;activities와-fragments-사이에서-값-전달하기&quot;&gt;Activities와 Fragments 사이에서 값 전달하기&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① Intent putExtra/getExtra &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② Bundle bundle.putString/bundle.getString &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ Parcelable &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;④ SharedPreference &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Image libraries</title>
        <description>&lt;h3 id=&quot;image-library&quot;&gt;Image Library&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;① Glide library&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) dependencies 추가하기&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Glide library
def glideVersion = '4.11.0'
implementation &quot;com.github.bumptech.glide:glide:$glideVersion&quot;
// Glide v4 uses this new annotation processor
annotationProcessor &quot;com.github.bumptech.glide:compiler:$glideVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) ImageView에 보여줄 이미지를 binding하는 부분에서 아래와 같이 Glide 라이브러리로 바인딩해준다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;[Basic Usage]&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Set the image
RequestOptions defaultOptions = new RequestOptions()
                                .error(R.drawable.ic_launcher_background);
Glide.with(mContext)
            .setDefaultRequestOptions(defaultOptions)
            .load(mNicePlaces.get(position).getImageUrl())
            .into(((Holder)holder).mImage);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Image-Library/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Image-Library/</guid>
        
        
        <category>Android-Libraries</category>
        
      </item>
    
      <item>
        <title>Kotlin &quot;companion object&quot;</title>
        <description>&lt;h3 id=&quot;companion-object-&quot;&gt;&lt;strong&gt;companion object ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Kotlin은 클래스에 static 필드를 갖게 할 수는 없지만, companion object의 구조를 이용해서 Java의 static 메소드와 동일한 동작을 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object {
        const val FREE_PRICE = 0
        fun newFreeBook(title: String) = Book(title, FREE_PRICE)
    }
}

fun main(){
  val book = Book.newFreeBook(&quot;Free Kotlin&quot;)
  println(book)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 companion object 뒤의 {}안에는 일반 클래스의 본체와 같이 구현을 한다. 위와 같이 도우미 개체를 정의하면 Book 클래스 안에 내재 된 싱글 톤 인스턴스(Singleton Instance)가 생성되며, Book.[Field name]형태로 액세스 할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;companion object는 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자체가 클래스 정의를 가지고 있으며, 외부에서 정의 된 클래스의 인스턴스가 아니다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
Book.xxx()라는 접근방식을 보면, 마치 Book 클래스의 싱글톤 인스턴스가 만들어지고 있는 것처럼 보이지만, Book인스턴스가 만들어지는 것은 아니다.&lt;br /&gt;
위의 Book.xxx()라는 문장은 사실 &lt;strong&gt;Book.Companion.xxx()&lt;/strong&gt;이 생략 기법이다. 이 점에서 companion object는 Book 클래스의 인스턴스와는 별개임을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 companion object{}의 형태로 작성할 수 있지만, 이 companion object에 이름을 넣어줄 수도 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object Factory{
      const val FREE_PRICE = 0
      fun freeBook(title: String) = Book(title, FREE_PRICE)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 도우미 객체는 Book.Factory.[Field name] 형태로 액세스 할 수 있다.&lt;br /&gt;
&lt;strong&gt;companion object는 클래스 내에서 하나 밖에 정의할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Android Kotlin Coroutine(비동기 처리)</title>
        <description>&lt;h3 id=&quot;coroutine--&quot;&gt;&lt;strong&gt;Coroutine ?&lt;/strong&gt; &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘Coroutine’에 대해 알아보기 전에 우선, ‘동기’와 ‘비동기’의 개념에 대해서 알아보자.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;동기(Synchronous) : will run in the same thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex1) 메인 스레드에서 실행&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 메인 스레드에서 실행
fun runMain(){
  val data = Weather.tomorrow()
  println(&quot;Tomorrow weather : ${data}&quot;)
}

fun Weather.tomorrow() : String{
  Thread.sleep(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;비동기(Asynchronous) : will run in a different thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex2) Coroutine으로 비동기 스레드 처리&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun runMain() : Job = viewModelScope.launch{
    val data = Weather.tomorrow()
    println(&quot;Tomorrow weather : ${data}&quot;)
}

suspend fun Weather.tomorrow() : String{
  delay(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ‘ex1’의 코드에서는 모두 Main Thread에서 실행하는 소스코드이다. 이는 동기적으로 호출해서 사용되고 있는 예이다.&lt;br /&gt;
동기적 처리는 2초 스레드가 차단되어버리는 문제가 있다. 이 스레드가 차단되는 동안에는 사용자의 조작이 얼어 버리기 때문에 응용 프로그램에서 이 코드를 작성하는 것은 현실적이지 않다. 한편 coroutin을 사용하면 결과가 나올 때까지 2초 사용자가 일반적으로 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 차이가 나는 이유는 &lt;strong&gt;coroutine에서 스레드를 차단하는 대신 처리를 &lt;font color=&quot;Red&quot;&gt;&quot;중단&quot;&lt;/font&gt;하기 때문이다.&lt;/strong&gt;&lt;br /&gt;
첫번째 소스 코드에서 Thread.sleep() 따라 2초 main thread를 점유(차단)하고, 그 동안 다른 작업을 하고 싶어도 메인 스레드가 사용할 수 없다. &lt;br /&gt;
한편 coroutine의 예에서 사용한 delay()함수는 2초간 차단하는 것이 아니라 &lt;strong&gt;main thread를 2초 동안 방출&lt;/strong&gt;하고  main thread를 다시 취득하고 처리를 계속한다. main thread가 개방되는 동안 다른 process에 thread를 활용할 수 있다. 이것을&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;&quot;중단(suspend)&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 ‘ex2’의 코드에서 delay() 같은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;중단이 발생하는 함수를 &quot;suspend 함수&quot;라 한다.&lt;/font&gt;&lt;/strong&gt; 일반 함수는 중단하지 않기 때문에, suspend 함수를 호출할 수 없다. &lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※suspend 함수를 호출하려면 launch에서 호출하거나 함수에 suspend 키워드를 붙여서 suspend fun을 호출해야 한다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;※ 이처럼 coroutine은 기본적으로 사용이 어렵지 않다. 기본적으로 &lt;font color=&quot;Red&quot;&gt;&quot;launch()&quot;&lt;/font&gt;에서 비동기 작업을 시작하고, &lt;font color=&quot;Red&quot;&gt;중단함수(launch{}내에서 실행할 함수)는 suspend로 선언해서 사용&lt;/font&gt;한다.&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;coroutinescope-&quot;&gt;&lt;strong&gt;CoroutineScope ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘ex2’ 예제 코드를 살펴보면 viewModelScope에 대한 launch{…}　호출로, &lt;strong&gt;coroutine을 시작하는 기능을 가진 개체를 &lt;font color=&quot;Red&quot;&gt;&quot;CoroutineScope&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 ‘CoroutineScope’는 coroutine의 &lt;strong&gt;시작뿐만 아니라 시작한 coroutine을 적절하게 종료하는 역할을 담당하고 있다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 Android KTX로 제공되는 &lt;strong&gt;“viewModelScope”&lt;/strong&gt;를 닫을때 coroutine을 자동으로 취소해준다.&lt;br /&gt;
Android에서 사용자 조작에 의한 처리를 하는 경우, “viewModelScope”에서 시작하는 것이 좋다. 병렬 프로그래밍을 하는데 있어 간과하기 쉬운 취소 처리도 CoroutineScope가 제대로 해줄 수 있게 되어있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val  job  =  runMain ()
// 개별적으로 작업을 취소한다.  
job . cancel ()

runMain ()

// viewModelScope를 cancel()하게 되면, viewModelScope에서 실행 한 작업을 모두 취소 할 수 있다.
viewModelScope . cancel ()  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;launch-내에서-호출해서-사용할-suspend-함수를-작성하는-방법에-대해-알아보자&quot;&gt;&lt;strong&gt;launch{} 내에서 호출해서 사용할 suspend 함수를 작성하는 방법에 대해 알아보자.&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① 블록처리를 suspend 함수로 변환&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow():String = withContext(Dispatchers.IO){
    Thread.sleep(2000)
    &quot;Text&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;→ &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;withContext(Dispatchers.IO){...}&lt;/font&gt;&lt;/strong&gt;에서 다른 스레드를 사용하여 실행하고, withContext() 처리가 완료되기 전까지 메인 스레드를 개방할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② 콜백함수를 suspend 함수로 변환&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun Weather.tomorrow(callback : (String) -&amp;gt; Unit) : Unit {
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({callback(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCoroutine{...}를 사용해서 suspend함수로 변환&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weathers.tomorrow() : String = suspendCoroutine{ c -&amp;gt;
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({c.resume(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCancellableCoroutine{...}를 사용해서 suspend함수로 변환하는 것을 추천&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow() : String = suspendCancellableCoroutine{ c -&amp;gt;
  // cancel 대응을 위한 코드 ① : 콜백 처리를 위한 변수
  val callback = Runnable {
      // 취소 대응을 위한 코드 ②
      if(c.isActive) c.resume(&quot;Text&quot;)
  }

  val handler = Handler()
  // cancel 대응을 위한 코드 ③ : coroutine 취소가 일어 났을 때 Handler 측도 취소한다.
  c.invokeOnCancellation{handler.removeCallbacks(callback)}

  // 2 초후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그 동안 스레드가 해제된다.
  handler.postDelayed(callback, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://qiita.com/wm3/items/48b5b5c878561ff4761a&quot;&gt;https://qiita.com/wm3/items/48b5b5c878561ff4761a&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
  </channel>
</rss>
