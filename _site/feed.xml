<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lee Hyungi's Tech Blog</title>
    <description>Hyungi's Ideas &amp; Blogs</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 17 Apr 2020 05:32:31 +0900</pubDate>
    <lastBuildDate>Fri, 17 Apr 2020 05:32:31 +0900</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Android Jetpack Navigation Component</title>
        <description>&lt;h3 id=&quot;android-jetpack-navigation-component&quot;&gt;Android Jetpack Navigation Component&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 포스팅에서는 Jetpack Navigation Component를 활용하여 Fragment간의 전이 처리하는 것에 대해서 배워 볼 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;① app gradle에 dependencies 추가하기&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def nav_version = &quot;2.3.0-alpha05&quot;
// Kotlin
implementation &quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;
implementation &quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;

def material_version = &quot;1.2.0-alpha05&quot;
implementation &quot;com.google.android.material:material:$material_version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;※ navigation graph 기능&lt;/p&gt;

&lt;p&gt;(1) resouce - [New Resource File] - (File name : nav_graph / Resource type : Navigation)&lt;br /&gt;
(2) 위의 nav_graph 파일에 화면에 보여질 UI의 화면 설계구조를 구조화시킬 수 있다.&lt;br /&gt;
(3) activity_main.xml 에서 &lt;fragment&gt; tag로 화면을 채우는데 &lt;strong&gt;이 부분이 각각 생성한 Fragment layout을 inflate하는 부분&lt;/strong&gt;이 될 것이다.&lt;br /&gt;
이 fragment tag안에 속성에서 살펴볼 것은, &lt;strong&gt;defaultNavHost = &quot;true&quot;와 app:navGraph = &quot;@navigation/nav_graph&quot; 인데 두번째 navGraph 속성은 navigation type의 layout에 생성할 layout의 구조를 setting하겠다는 의미, 마지막으로 android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;속성도 필수적으로 설정해주어야 한다.&lt;/strong&gt;&lt;br /&gt;&lt;/fragment&gt;&lt;/p&gt;

&lt;p&gt;(4) 작성한 Fragment layout파일(*.xml)에서 가장 상단 tag의 속성에 &lt;strong&gt;tools:context = “xxxxxFragment” &lt;/strong&gt;라고 지정해주어야 한다.&lt;br /&gt;
이 layout 파일이 어느 fragment 클래스 파일과 관련이 있는지 표시하기 위해서이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;② MainActivity에서는 화면의 fragment 태그에서 fragment 레이아웃을 보여주는 기능만 하므로, 실질적인 Navigation 객체를 만들어서 처리해주는 것은 Fragment class에서 해줄 것이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) onViewCreated() 메소드에서 property로 선언한 NavController 타입의 변수를 초기화시켜준다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    // reference of the view
    navController = Navigation.findNavController(view)
    view_transactions_btn.setOnClickListener(this)
    send_money_btn.setOnClickListener(this)
    view_balance_btn.setOnClickListener(this)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 MainFragment도 nav_graph에 등록된 Fragment이기 때문에 navController객체의 생성이 가능하다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 이제 이 navController를 이용해서 각 버튼의 onClickListener의 이벤트를 구현할 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onClick(v: View?) {
  // backStack관리가 자동으로 이루어지기 때문에 편리하다.
  when(v!!.id){
      R.id.view_transactions_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewTransactionFragment)
      R.id.send_money_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_chooseRecipientFragment)
      R.id.view_balance_btn -&amp;gt; navController.navigate(R.id.action_mainFragment_to_viewBalanceFragment)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ②-(1)과 (2)의 과정을 다른 Fragment에서도 작성을 작성해준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;③ 다음 과정에서는 animation, bundle을 추가하는 과정이다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Jetpack-Navigation-Component/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Android Kotlin 범위 함수 사용정리</title>
        <description>&lt;p&gt;이번 포스팅에서는 Kotlin 범위 함수 사용에 대해서 정리한다.&lt;br /&gt;
&lt;strong&gt;Kotlin의 표준 라이브러리에는 “범위함수”라는 4가지 기능&lt;/strong&gt;이 있다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;let, with, run, apply&lt;/font&gt;&lt;/strong&gt;이다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;let-&quot;&gt;&lt;strong&gt;.let ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.let{it.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let은 어떤 형태의 확장 기능&lt;/strong&gt;이다.&lt;br /&gt;
위의 예에서는 String 인스턴스를 “hoge”를 it으로 받아 처리하고 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;with-&quot;&gt;&lt;strong&gt;with ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = with(&quot;hoge&quot;){this.toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 알 수 있듯이 &lt;strong&gt;let과 달리 확장함수&lt;/strong&gt;가 없다.&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른 예시로, &lt;strong&gt;예를 들어 String? 변수 foo의 대소 표현을 얻고 싶은 경우에는 아래와 같이 작성할 수 있다.&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val upperCase : String? = foo?.let{it.toUpperCase()}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;foo가 null인 경우에는 ?. 호출에 의해 let이 실행되지 않고 null을 반환한다.&lt;br /&gt;
foo가 null이 아닌경우, let이 실행 it.toUpperCase()에 의해 foo 대문자 표현을 반환한다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;run-&quot;&gt;&lt;strong&gt;run ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val s = &quot;hoge&quot;.run{toUpperCase()}
println(s) // HOGE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;let 그리고 with이 합쳐진 버전이다.&lt;/strong&gt;&lt;br /&gt;
첫 번째 인수에 &lt;strong&gt;임의의 형태 T&lt;/strong&gt;를 취한다. &lt;br /&gt;
this는 “hoge”를 의미하며, 선택적이므로 {toUpperCase()}로 기술해도 된다.&lt;br /&gt;
인스턴스를 생성하고 각종 설정을 한 후 실제로 바로 사용하기 위해서 사용된다.&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;apply-&quot;&gt;&lt;strong&gt;.apply ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;우선 .apply를 사용해서 recyclerView의 LayoutManager와 adapter를 초기해준 아래 예를 같이 살펴보자. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun initRecyclerView(){
    // apply 를 사용해서 layoutManager 와 adapter 를 지정해주었을때,
    recycler_view.apply {
        layoutManager = LinearLayoutManager(this@MainActivity)
        blogAdapter = BlogRecyclerAdapter(context,[dataSet])
        adapter = blogAdapter
    }

    // recycler_view를 지정해주면서 layoutManager 와 adapter 를 지정해주었을때
    recycler_view.layoutManager = LinearLayoutManager(this@MainActivity)
    blogAdapter = BlogRecyclerAdapter(this,[dataSet])
    recycler_view.adapter = blogAdapter
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확실히 apply annotation을 사용해서 recycler_view를 초기화 시켜주면, 매번 recycler_view를 호출해서 사용하지 않아도 가볍게 layoutManager와 adapter 키워드만으로도 초기화 시켜줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/16/Android-Kotlin-%EB%B2%94%EC%9C%84-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EC%A0%95%EB%A6%AC/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Kotlin Singleton Example with MVVM and coroutines</title>
        <description>&lt;h3 id=&quot;kotlin-singleton-example-with-mvvm-and-coroutines&quot;&gt;Kotlin Singleton Example with MVVM and coroutines&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;이번 Post에 정리할 내용은 아래와 같다.&lt;br /&gt;
2 examples :&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) Quick “how to”&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2)Practical example&lt;br /&gt;
-Retrofit&lt;br /&gt;
-Coroutines&lt;br /&gt;
-MVVM&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Singletons&lt;/p&gt;

&lt;p&gt;Instance of an object &lt;br /&gt;
reuse the instance &lt;br /&gt;
Retrofit instance &lt;br /&gt;
Repository instance &lt;br /&gt;
User sessions &lt;br /&gt;
Dagger(Dependency Injection/Provide Singleton)
Dagger라이브러리는 좀 어렵다. 나중에 별도의 강의로 이해하도록 하자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자 이제 실제로 Singleton 패턴의 클래스를 Kotlin으로 작성해보자.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① 우선 models패키지를 작성을 하고, 그 안에 User라는 data class를 작성해준다. &lt;br /&gt;
② 다음으로 ExampleSingleton을 이름으로 하는 Object클래스를 작성한다. 이 클래스 안에는 앞서 작성한 User클래스를 아래와 같이 객체를 만들어준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val singletonUser: User by lazy {
  User(&quot;email@gmail.com&quot;, &quot;username&quot;, &quot;image.png&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;lazy키워드를 사용해서 변수를 위임하면 실제로 해당 속성이 호출되서 사용될때, 초기화가 된다.&lt;br /&gt;
(클래스가 인스턴스화되는 타이밍에는 해당 속성은 메모리상에 초기화되지 않는다) &lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ MainActivity의 onCreate 메소드 내에서 Singleton클래스 내부에서 작성한 singletonUser 변수의 hashCode를 확인해서 실제 화면의 configuration(portrait/landscape)가 변경이 되었을때, 같은 메모리 주소를 반환하고 있는지 확인해본다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;println(&quot;DEBUG: ${ExampleSingleton.singletonUser.hashCode()}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 화면의 configuration을 바꿨을때, 매번 같은 hashCode를 반환함을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
I/System.out: DEBUG: -1198862957
D/EGL_emulation: eglMakeCurrent: 0xdb71a480: ver 3 0 (tinfo 0xdb70f7a0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 다음으로, api 패키지를 작성하고, MyRetrofitBuilder(Object클래스)와 ApiService 인터페이스를 작성해볼 것이다. &lt;br /&gt;
MyRetrofitBuilder클래스를 Object클래스 타입으로 작성하는 이유는 Kotlin에서는 Object클래스로 작성한다는 의미가 바로 ‘Singleton’으로 작성하겠다는 의미이기 때문이다. ApiService인터페이스에서는 Retrofit을 사용해 통신상으로터 데이터를 취득하는 메소드를 작성할 것이다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;MyRetrofitBuilder.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object MyRetrofitBuilder {

    const val BASE_URL = &quot;https://open-api.xyz/&quot;

    // Singleton Retrofit builder
    val retrofitBuilder: Retrofit.Builder by lazy {
      Retrofit.Builder()
      .baseUrl(BASE_URL)
      .addConverterFactory(GsonConverterFactory.create())
      // 서버로부터 호출되는 데이터의 형식은 JSON형태이므로, 이를 Convert할 Converter가 필요하다.
      // Gson Converter = JSON objcet -&amp;gt; Java object
    }

    // Singleton apiService (Network request)
    val apiService: ApiService by lazy {
      retrofitBuilder
      .build()
      .create(ApiService::class.java)
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ApiService.kt&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ApiService {

    @GET(&quot;placeholder/user/{userId}&quot;)
    // 여기서 사용되는 suspend fun은 'coroutine'을 사용하기 위한 fun이다.
    // use 'coroutine' fun return the date from network.
    suspend fun getUser(
        @Path(&quot;userId&quot;) userId: String
    ): User
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;‘suspend fun’을 사용하면 ‘coroutine’을 사용한다는 의미이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑤ &lt;strong&gt;Repository&lt;/strong&gt;패키지 추가하고, Repository Object클래스 작성하기.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Repository{

    var job: CompletableJob? = null

    fun getUser(userId: String): LiveData&amp;lt;User&amp;gt; {
      // job을 초기화시켜준다.
      job = Job()
      return object: LiveData&amp;lt;User&amp;gt;(){
          override fun onActive(){
            super.onActive()
            // 우선 job이 null인지 아닌지 검사를 한다.
            job?.let{ theJob-&amp;gt;
              // job이 null이 아닌경우, 실행을 한다.
              // IO(Dispatchers)+theJob으로 유니크한 CoroutineScope를 background thread에 생성을 한다.
              CoroutineScope(IO+theJob).launch{
                val user = MyRetrofitBuilder.apiService.getUser(userId)
                // live data를 background thread에 해줄 수 없으므로,
                // 우선 MAIN 스레드로 전환을 하고, live data를 setting해주어야 한다.
                withContext(Main){
                  value = user
                  theJob.complete()
                }
              }
            }
          }
      }  
    }
    // job을 calcel하는 method이다.
    fun cancelJob(){
        job?.cancel()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑥ MainViewModel 클래스를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainViewModel : ViewModel() {
    private val _userId: MutableLiveData&amp;lt;String&amp;gt; = MutableLiveData()

    // Transformations _userId에 변화가 생기면 .switchMap 이 trigger 되고 {}안에 코드가 실행된다.
    val user: LiveData&amp;lt;User&amp;gt; = Transformations
          .switchMap(_userId){
              // 기존 _userId에 변화가 생겼으니, 업데이트를 해주어야 한다.
              // 따라서, Repository.getUser를 통해서 새로운 uerId를 취득해서 위에 String변수를 초기화 시켜준다.
              Repository.getUser(it)
          }

    fun setUserId(userId: String){
         val update = userId

         // 현재의 userId가 이미 setting 되었다면 종료한다.
         if(_userId.value == update){
              return
          }
         // 기존의 userId를 update된 새로운 userId로 초기화시킨다.
          _userId.value = update
    }  

    // Repository에서 작성한 cancelJobs() 메소드를 viewModel클래스의 cancelJobs()메소드 안에 작성해준다.
    fun cancelJobs(){
        Repository.cancelJobs()
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑦ MainActivity에서 작성한 MainViewModel클래스의 instance를 작성해서, Observe(변수의 변화가 감지되었을때)를 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    lateinit var viewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)

        viewModel.user.observe(this, Observer {user -&amp;gt;
            println(&quot;DBUG: $user&quot;)
        })
        viewModel.setUserId(&quot;1&quot;)
    }

    override fun onDestroy() {
        super.onDestroy()
        viewModel.cancelJobs()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 15 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/15/Kotlin-Singleton-Example-with-MVVM-and-Coroutines/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
      <item>
        <title>Transfer data between Activities and Fragments</title>
        <description>&lt;h3 id=&quot;activities와-fragments-사이에서-값-전달하기&quot;&gt;Activities와 Fragments 사이에서 값 전달하기&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① Intent putExtra/getExtra &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② Bundle bundle.putString/bundle.getString &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③ Parcelable &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;④ SharedPreference &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Transfer-data-between-Activities-and-Fragments/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Image libraries</title>
        <description>&lt;h3 id=&quot;image-library&quot;&gt;Image Library&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;① Glide library&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) dependencies 추가하기&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Glide library
def glideVersion = '4.11.0'
implementation &quot;com.github.bumptech.glide:glide:$glideVersion&quot;
// Glide v4 uses this new annotation processor
annotationProcessor &quot;com.github.bumptech.glide:compiler:$glideVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(2) ImageView에 보여줄 이미지를 binding하는 부분에서 아래와 같이 Glide 라이브러리로 바인딩해준다.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;[Basic Usage]&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Set the image
RequestOptions defaultOptions = new RequestOptions()
                                .error(R.drawable.ic_launcher_background);
Glide.with(mContext)
            .setDefaultRequestOptions(defaultOptions)
            .load(mNicePlaces.get(position).getImageUrl())
            .into(((Holder)holder).mImage);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Image-Library/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Image-Library/</guid>
        
        
        <category>Android-Libraries</category>
        
      </item>
    
      <item>
        <title>Kotlin &quot;companion object&quot;</title>
        <description>&lt;h3 id=&quot;companion-object-&quot;&gt;&lt;strong&gt;companion object ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Kotlin은 클래스에 static 필드를 갖게 할 수는 없지만, companion object의 구조를 이용해서 Java의 static 메소드와 동일한 동작을 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object {
        const val FREE_PRICE = 0
        fun newFreeBook(title: String) = Book(title, FREE_PRICE)
    }
}

fun main(){
  val book = Book.newFreeBook(&quot;Free Kotlin&quot;)
  println(book)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 companion object 뒤의 {}안에는 일반 클래스의 본체와 같이 구현을 한다. 위와 같이 도우미 개체를 정의하면 Book 클래스 안에 내재 된 싱글 톤 인스턴스(Singleton Instance)가 생성되며, Book.[Field name]형태로 액세스 할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;companion object는 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;자체가 클래스 정의를 가지고 있으며, 외부에서 정의 된 클래스의 인스턴스가 아니다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
Book.xxx()라는 접근방식을 보면, 마치 Book 클래스의 싱글톤 인스턴스가 만들어지고 있는 것처럼 보이지만, Book인스턴스가 만들어지는 것은 아니다.&lt;br /&gt;
위의 Book.xxx()라는 문장은 사실 &lt;strong&gt;Book.Companion.xxx()&lt;/strong&gt;이 생략 기법이다. 이 점에서 companion object는 Book 클래스의 인스턴스와는 별개임을 알 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 companion object{}의 형태로 작성할 수 있지만, 이 companion object에 이름을 넣어줄 수도 있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data class Book(val title: String, val price: Int){
    companion object Factory{
      const val FREE_PRICE = 0
      fun freeBook(title: String) = Book(title, FREE_PRICE)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 도우미 객체는 Book.Factory.[Field name] 형태로 액세스 할 수 있다.&lt;br /&gt;
&lt;strong&gt;companion object는 클래스 내에서 하나 밖에 정의할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-companion-object/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Android Kotlin Coroutine(비동기 처리)</title>
        <description>&lt;h3 id=&quot;coroutine--&quot;&gt;&lt;strong&gt;Coroutine ?&lt;/strong&gt; &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘Coroutine’에 대해 알아보기 전에 우선, ‘동기’와 ‘비동기’의 개념에 대해서 알아보자.&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;동기(Synchronous) : will run in the same thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex1) 메인 스레드에서 실행&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 메인 스레드에서 실행
fun runMain(){
  val data = Weather.tomorrow()
  println(&quot;Tomorrow weather : ${data}&quot;)
}

fun Weather.tomorrow() : String{
  Thread.sleep(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;비동기(Asynchronous) : will run in a different thread.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;ex2) Coroutine으로 비동기 스레드 처리&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun runMain() : Job = viewModelScope.launch{
    val data = Weather.tomorrow()
    println(&quot;Tomorrow weather : ${data}&quot;)
}

suspend fun Weather.tomorrow() : String{
  delay(2000)
  return &quot;sunny&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 ‘ex1’의 코드에서는 모두 Main Thread에서 실행하는 소스코드이다. 이는 동기적으로 호출해서 사용되고 있는 예이다.&lt;br /&gt;
동기적 처리는 2초 스레드가 차단되어버리는 문제가 있다. 이 스레드가 차단되는 동안에는 사용자의 조작이 얼어 버리기 때문에 응용 프로그램에서 이 코드를 작성하는 것은 현실적이지 않다. 한편 coroutin을 사용하면 결과가 나올 때까지 2초 사용자가 일반적으로 수행할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 차이가 나는 이유는 &lt;strong&gt;coroutine에서 스레드를 차단하는 대신 처리를 &lt;font color=&quot;Red&quot;&gt;&quot;중단&quot;&lt;/font&gt;하기 때문이다.&lt;/strong&gt;&lt;br /&gt;
첫번째 소스 코드에서 Thread.sleep() 따라 2초 main thread를 점유(차단)하고, 그 동안 다른 작업을 하고 싶어도 메인 스레드가 사용할 수 없다. &lt;br /&gt;
한편 coroutine의 예에서 사용한 delay()함수는 2초간 차단하는 것이 아니라 &lt;strong&gt;main thread를 2초 동안 방출&lt;/strong&gt;하고  main thread를 다시 취득하고 처리를 계속한다. main thread가 개방되는 동안 다른 process에 thread를 활용할 수 있다. 이것을&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;&quot;중단(suspend)&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 ‘ex2’의 코드에서 delay() 같은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;중단이 발생하는 함수를 &quot;suspend 함수&quot;라 한다.&lt;/font&gt;&lt;/strong&gt; 일반 함수는 중단하지 않기 때문에, suspend 함수를 호출할 수 없다. &lt;br /&gt;
&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※suspend 함수를 호출하려면 launch에서 호출하거나 함수에 suspend 키워드를 붙여서 suspend fun을 호출해야 한다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;※ 이처럼 coroutine은 기본적으로 사용이 어렵지 않다. 기본적으로 &lt;font color=&quot;Red&quot;&gt;&quot;launch()&quot;&lt;/font&gt;에서 비동기 작업을 시작하고, &lt;font color=&quot;Red&quot;&gt;중단함수(launch{}내에서 실행할 함수)는 suspend로 선언해서 사용&lt;/font&gt;한다.&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;coroutinescope-&quot;&gt;&lt;strong&gt;CoroutineScope ?&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;‘ex2’ 예제 코드를 살펴보면 viewModelScope에 대한 launch{…}　호출로, &lt;strong&gt;coroutine을 시작하는 기능을 가진 개체를 &lt;font color=&quot;Red&quot;&gt;&quot;CoroutineScope&quot;&lt;/font&gt;&lt;/strong&gt;라고 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 ‘CoroutineScope’는 coroutine의 &lt;strong&gt;시작뿐만 아니라 시작한 coroutine을 적절하게 종료하는 역할을 담당하고 있다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 Android KTX로 제공되는 &lt;strong&gt;“viewModelScope”&lt;/strong&gt;를 닫을때 coroutine을 자동으로 취소해준다.&lt;br /&gt;
Android에서 사용자 조작에 의한 처리를 하는 경우, “viewModelScope”에서 시작하는 것이 좋다. 병렬 프로그래밍을 하는데 있어 간과하기 쉬운 취소 처리도 CoroutineScope가 제대로 해줄 수 있게 되어있다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val  job  =  runMain ()
// 개별적으로 작업을 취소한다.  
job . cancel ()

runMain ()

// viewModelScope를 cancel()하게 되면, viewModelScope에서 실행 한 작업을 모두 취소 할 수 있다.
viewModelScope . cancel ()  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;launch-내에서-호출해서-사용할-suspend-함수를-작성하는-방법에-대해-알아보자&quot;&gt;&lt;strong&gt;launch{} 내에서 호출해서 사용할 suspend 함수를 작성하는 방법에 대해 알아보자.&lt;/strong&gt;&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① 블록처리를 suspend 함수로 변환&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow():String = withContext(Dispatchers.IO){
    Thread.sleep(2000)
    &quot;Text&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;→ &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;withContext(Dispatchers.IO){...}&lt;/font&gt;&lt;/strong&gt;에서 다른 스레드를 사용하여 실행하고, withContext() 처리가 완료되기 전까지 메인 스레드를 개방할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② 콜백함수를 suspend 함수로 변환&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun Weather.tomorrow(callback : (String) -&amp;gt; Unit) : Unit {
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({callback(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCoroutine{...}를 사용해서 suspend함수로 변환&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weathers.tomorrow() : String = suspendCoroutine{ c -&amp;gt;
  // 2초 후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그동안 스레드가 해제된다.
  val handler = Handler()
  handler.postDelayed({c.resume(&quot;Text&quot;)}, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;suspendCancellableCoroutine{...}를 사용해서 suspend함수로 변환하는 것을 추천&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;suspend fun Weather.tomorrow() : String = suspendCancellableCoroutine{ c -&amp;gt;
  // cancel 대응을 위한 코드 ① : 콜백 처리를 위한 변수
  val callback = Runnable {
      // 취소 대응을 위한 코드 ②
      if(c.isActive) c.resume(&quot;Text&quot;)
  }

  val handler = Handler()
  // cancel 대응을 위한 코드 ③ : coroutine 취소가 일어 났을 때 Handler 측도 취소한다.
  c.invokeOnCancellation{handler.removeCallbacks(callback)}

  // 2 초후 처리를 호출하도록 타이머를 설정한다.
  // callback 처리는 메인 스레드에서 행해지고, 그 동안 스레드가 해제된다.
  handler.postDelayed(callback, 2000)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://qiita.com/wm3/items/48b5b5c878561ff4761a&quot;&gt;https://qiita.com/wm3/items/48b5b5c878561ff4761a&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>Android Kotlin Coroutine Basic</title>
        <description>&lt;h3 id=&quot;coroutine--&quot;&gt;&lt;strong&gt;Coroutine ?&lt;/strong&gt; &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;Work with Background thread &lt;br /&gt;
Coroutine은 AsyncTask 와 같이 Threading하는 방법 중에 하나이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/android/2020-04-16 coroutine thread.png&quot; alt=&quot;blog capture&quot; title=&quot;capture img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ 아래와 같은 상황에서 Coroutine은 유용하게 쓰인다.&lt;/strong&gt;&lt;br /&gt;
① Request to network retrofit volley 등의 통신 라이브러리를 사용할때, Main Thread가 Block된다.&lt;br /&gt;
② Accessing the internal SQLite database on the phone. ex) Room database&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;위의 두가지 경우에서 일반적으로 background thread가 사용이 된다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;simulate network request and internal room database.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;Sequence&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;
(1) Get the result value from background thread.&lt;br /&gt;
(2) Take the result and then display on the main thread.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Android 개발을 하다보면 Network나 내부 데이터베이스로부터 데이터를 취득해서 순차적으로 취득한 데이터를 처리해야 되는 경우가 있다. &lt;br /&gt;
이런 경우는 이미 경험을 해봤었기 때문에 얼마나 큰 문제인지 알고 있다. 이 문제를 해결하기 위해서는 RxJava나 callback함수를 사용해서 작성을 하면, 코드가 매우 복잡해지기 때문에, Coroutine을 사용해서 작성을 하면 Simple하게 코드를 작성할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① Gradle에 Coroutine과 관련된 dependencies를 추가한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def coroutines_version = &quot;1.2.1&quot;
implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version&quot;
implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;② debug용으로 log를 확인하기 위해 “logThread” 메소드를 작성한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun logThread(methodName: String){
    println(&quot;debug: ${methodName}: ${Thread.currentThread().name}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;③ 테스트용으로 Api로부터 결과값을 가져오는 메소드(suspend)를 두개 작성한다. 이는 순차적으로 취득하는 데이터를 최종적으로 Main thread의 UI요소에 반영하기 위함이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun getResult1FromApi():String{
    logThread(&quot;getResult1FromApi&quot;)
    delay(1000) // sleep single coroutine
    //Thread.sleep(1000) // sleep all coroutine
    return RESULT_1 // &quot;Result #1&quot;
}

private suspend fun getResult2FromApi(): String{
    logThread(&quot;getResult2FromApi&quot;)
    delay(1000)
    return RESULT_2 // &quot;Result #2&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;④ 위에서 작성한 Api취득 메소드를 fakeApiResult() 메소드(suspend) 내에서 처리하도록 작성한다. &lt;br /&gt;
   여기서 테스트해볼 것은 api로부터 취득한 값을 UI상에 표시하는 테스트를 해볼 것이다. 하지만 &lt;strong&gt;현재 fakeApiResult()메소드가 실행되는 thread는 Main thread가 아닌 Background thread&lt;/strong&gt;이므로, &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;UI에서 처리하기 위해서는 취득한 값을 &quot;Main thread&quot;로 보내서 UI에 표시처리해야 한다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun fakeApiResult(){
    val result1 = getResult1FromApi()
    println(&quot;debug: $result1&quot;)
    setTextOnMainThread(result1)

    // result1 부분이 처리된 후에 result2부분이 순차적으로 실행될 것이다.
    val result2 = getResult2FromApi()
    setTextOnMainThread(result2)
    //text.setText(result1) //이 작업은 crash 될 것이다.
    // 그 이유는 background thread 에서 작업을 하고 있고,
    // 실제 UI와 interact 하고 있는 thread 는 Main thread 이기 때문이다.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;setTextOnMainThread() 메소드 (Main thread로 thread를 전환하여 취득한 결과 값을 UI반영하기)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private suspend fun setTextOnMainThread(input: String){
    //CoroutineScope(Main)로 하거나
    withContext(Main){
      setNewText(input)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;UI 상에 있는 TextView에 text를 setting하는 메소드&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun setNewText(input: String){
    val newText = text.text.toString() + &quot;\n$input&quot;
    text.text = newText
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑤ 마지막으로 onCreate()메소드에 작성한 코드를 살펴보자. 이 코드에서 주목해야 될 부분은 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;&quot;CoroutineScope&quot;&lt;/font&gt;&lt;/strong&gt;이다. CoroutineScope의 option으로는 &lt;strong&gt;&lt;font color=&quot;Blue&quot;&gt;IO, Main, Default&lt;/font&gt;&lt;/strong&gt;가 있다. 각 option은 다른 Thread 기능을 하는데, &lt;strong&gt;IO(Input/Output) thread의 경우, Network, local database interaction 기능&lt;/strong&gt;을 하며, &lt;strong&gt;Main thread&lt;/strong&gt;의 경우, UI 요소와 상호작용하는 역할을 한다. 이외에 Default option은 heavy competition work를 다룰때 사용한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)

      button.setOnClickListener{
          // IO(Network, local database interaction),
          // Main(Main thread, interact with UI),
          // Default(heavy competition work)
          CoroutineScope(IO).launch {
              //launch (coroutine builder)
              fakeApiResult()
          }
      }
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0&quot;&gt;Android coroutines codelab&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine-basic/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/Android-Kotlin-Coroutine-basic/</guid>
        
        
        <category>Android-Kotlin</category>
        
      </item>
    
      <item>
        <title>MVVM Architecture Image Training</title>
        <description>&lt;h2 id=&quot;mvvm-architecture&quot;&gt;MVVM Architecture&lt;br /&gt;&lt;/h2&gt;

&lt;h3 id=&quot;java-&quot;&gt;Java &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;① ViewModel Class&lt;/font&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(1) class 선언하기&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivityViewModel extends ViewModel {

    private MutableLiveData&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt; mNicePlaces;

    public LiveData&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt; getNicePlaces(){return mNicePlaces;}

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스를 선언할때에는 ViewModel 클래스를 상속하고, field변수로 MutableLiveData&amp;lt;List&lt;NicePlace&gt;&amp;gt;타입의 변수를 선언해준다. Field변수로 선언을 해줄때는 값이 변화하기 때문에 MutableLiveData 타입으로 선언하지만, 이 값을 읽어올때는 LiveData&amp;lt;List&lt;NicePlace&gt;&amp;gt; 타입으로 선언해준다. &lt;br /&gt;&lt;/NicePlace&gt;&lt;/NicePlace&gt;&lt;/p&gt;

&lt;p&gt;(2) MainActivity에서 작성한 MainActivityViewModel 인스턴스를 만들어서 초기화시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mMainActivityViewModel = ViewModelProviders.of(this).get(MainActivityViewModel.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;우선, dependencies에 Lifecycle components dependency를 넣어준다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Lifecycle components
def archLifecycleVersion = '1.1.1'
implementation &quot;android.arch.lifecycle:extensions:$archLifecycleVersion&quot;
annotationProcessor &quot;android.arch.lifecycle:compiler:$archLifecycleVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음으로 해줄 것은 &lt;strong&gt;데이터가 변화하는 것을 관찰하기 위한 설정&lt;/strong&gt;을 할 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mMainActivityViewModel.getNicePlaces().observe(this, new Observer&amp;lt;List&amp;lt;NicePlace&amp;gt;&amp;gt;() {
    @Override
    public void onChanged(List&amp;lt;NicePlace&amp;gt; nicePlaces) {
        mNicePlaceRecycleAdapter.notifyDataSetChanged();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이젠 데이터가 변할때마다 변화된 데이터를 화면에 잘 출력할 수 있도록 adapter를 초기화시켜줄때 이 변화된 데이터로 초기화를 시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void initRecyclerView(){
  mAdapter = new RecyclerAdapter(this, mMainActivityViewModel.getNicePlaces().getValue());
  RecyclerView.LayoutManager linearLayoutManager = new LinearLayoutManager(this);
  mRecyclerView.setLayoutManager(linearLayoutManager);
  mRecyclerView.setAdapter(mAdapter);
}    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(3) Repository 클래스를 작성해준다.&lt;br /&gt;
    이 Repository클래스에서는 실제 화면에 보여지는 Data의 setter와 getter메소드가 있는 클래스이다.&lt;br /&gt;
    Repository class는 Singleton으로 작성을 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(4) 작성한 Repository 클래스를 활용하여, ViewModel 클래스에서 init() 메소드를 작성해준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void init(){
  if(mNicePlaces != null){
      return;
  }
  mRepo = NicePlaceRepository.getInstance();
  mNicePlaces = mRepo.getNicePlaces();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 작성한 init() 메소드는 MainActivity에서 ViewModel 클래스를 초기화시켜줄때, 기존의 dataSet변수가 ‘null’인 경우, ViewModel 클래스 객체를 초기화시켜준 다음에 Repository로부터 데이터를 가져와서 데이터를 초기화시켜주는 작업을 한다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kotlin-&quot;&gt;Kotlin &lt;br /&gt;&lt;/h3&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/14/MVVM-Architecture-Image-Training/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/14/MVVM-Architecture-Image-Training/</guid>
        
        
        <category>Android-Architecture</category>
        
      </item>
    
      <item>
        <title>RecyclerView를 Java/Kotlin으로 작성하기</title>
        <description>&lt;h3 id=&quot;recyclerview을-작성하기---recyclerviewadapter작성하기&quot;&gt;RecyclerView을 작성하기 - RecyclerViewAdapter작성하기.&lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;① RecyclerView Class를 초기화시켜 줄 두 개의 변수 (Context와 DataSet 변수)를 Field변수로 선언해준다.&lt;br /&gt;
→ 위와 같이 생성자에서 직접 Context와 DataSet을 초기화해줘도 되지만, 내부에 다른 DataSet 필드 변수를 초기화 시켜주는 메소드를 작성해서 해줄 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;② 새로운 생성자를 작성해주고, 그 생성자 안에서 ①에서 작성한 field변수를 초기화시켜준다.&lt;br /&gt;
③ 내부 클래스를 작성해준다. (이 내부 클래스에서는 Layout상에 있는 View요소를 초기화시켜준다. - UI element binding)&lt;br /&gt;
④ 나머지 Override 메소드를 implementation해준다.&lt;br /&gt;
⑤ onCreateViewHolder() - 이 부분에서는 parent View가 ‘null’인 경우에 custom listItem View를 Inflate해주고 holder 변수를 초기화시켜주는 부분이다.&lt;br /&gt;
⑥ onBindViewHolder() - 구체적인 위치에 데이터를 보여주는 곳이다. 각 position마다 보여질 데이터를 초기화 시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※RecyclerView의 OnClickListener의 가장 최고의 연습방법에 대해서 알아보자.(Java편)&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 방법은 일전에 Bravo라는 프로젝트를 했을 당시에 성전이 형한테 배웠던 방법이다. RecyclerView 내에 있는 아이템 클릭 이벤트를 구현할때, 아이템 클릭시 자동으로 UI내부의 요소를 동시에 업데이트 해주고 싶었는데, 아래와 같은 방식으로 했더니 원하는대로 작동이 되었었다. 나중을 위해서 아래의 내용을 정리해둔다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;① 우선 RecyclerViewAdapter 클래스 안에 onClick 메소드를 하나 가지고 있는 interface를 작성한다.&lt;br /&gt;
② 그 다음에는 작성한 interface를 구현할 MainActivity에 가서 class에 implement해준다.&lt;br /&gt;
③ Adapter클래스의 ViewHolder 내부 클래스에도 interface를 상속시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;④ Adapter클래스의 Holder 내부 클래스에서 OnNicePlaceClickListener를 아래와 같이 선언해준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Holder extends RecyclerView.ViewHolder implements View.OnClickListener {

    private ImageView mImage;
    private TextView mTitle;
    OnNicePlaceClickListener onNicePlaceClickListener;

    public Holder(@NonNull View itemView, OnNicePlaceClickListener onNicePlaceClickListener) {
        super(itemView);
        mImage = itemView.findViewById(R.id.image);
        mTitle = itemView.findViewById(R.id.image_name);
        this.onNicePlaceClickListener = onNicePlaceClickListener;
        itemView.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        onNicePlaceClickListener.onNicePlaceClick(getAdapterPosition());
    }
}

public interface OnNicePlaceClickListener{
    void onNicePlaceClick(int position);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑤ 기존에 onCreateViewHolder() 메소드 안에서 생성자 요소가 하나 추가 되었으므로, 외부 클래스 (Adapter)클래스에서도 필드 변수로 ‘mOnNicePlaceClickListener 인터페이스’를 선언해주고 생성자에서도 초기화를 시켜준다. &lt;br /&gt;
그 다음에 onCreateViewHolder() 메소드 안에서도 Holder 내부 클래스를 초기화 시켜주는 요소로 mOnNicePlaceClickListener를 추가해준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑥ 그 다음으로 MainActivity에서 Adapter를 초기화 시켜줄때, 두번째 요소에 this를 넣어 초기화시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※RecyclerView의 OnClickListener의 가장 최고의 연습방법에 대해서 알아보자.(Kotlin편)&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;RecyclerView는 built-in onClickListener 메소드가 없기 때문에, Lambda식으로 RecyclerView의 click이벤트를 처리해줘야 한다.&lt;br /&gt;
기존에 선언한 Aapter에서 Parameter로 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;itemClick:(T)-&amp;gt;Unit&lt;/font&gt;&lt;/strong&gt;를 넘겨줘야 한다.&lt;br /&gt;
클릭했을때, Category 객체를 넘겨주지만, 결과적으로 아무것도 반환하지 않기 때문에, Unit으로 처리를 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ViewHolder(내부 클래스)의 Parameter에도 &lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;val itemClick: (Category) -&amp;gt; Unit&lt;/font&gt;&lt;/strong&gt;를 넘겨서 내부 메소드 내에 itemView.setOnClickListener{itemClick(category)}로 작성해준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;⑦ Adapter클래스를 초기화시켜서 사용하는 클래스(MainActivity)에서 Lambda식으로 Adapter클래스를 초기화 시켜줄때　OnClickListener도 함께 초기화를 시켜준다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;Red&quot;&gt;※ Kotlin에서는 위의 방법 이외에 앞서 Java에서 interface를 구현해서 클릭 이벤트를 구현했던 방식으로도 할 수 있다.&lt;/font&gt;&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;“OnItemClickListener”&lt;/strong&gt;interface를 Adapter클래스에 추가한다.&lt;br /&gt;
②Adapter클래스의 Field변수로 OnItemClickListener를 선언한다.&lt;br /&gt;
③OnItemClickListener의 setter메소드를 작성한다.&lt;br /&gt;
④ViewHolder 내부 클래스 안에 아래와 같이 OnClickListener를 setting한다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;itemView.setOnClickListener{
      mOnPostClickListener.onClick(blogPost)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⑤MainActivity에서 adapter를 초기화 시키는 부분에서 interface의 setter 메소드를 사용해서 interface를 구현해준다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun initRecyclerView(){
    // apply 를 사용해서 layoutManager 와 adapter 를 지정해주었을때,
    recycler_view.apply {
        layoutManager = LinearLayoutManager(this@MainActivity)
        blogAdapter = BlogRecyclerAdapter()
        blogAdapter.setOnPostClickListener(onPostClickListener)
        val topSpacingDecoration = TopSpacingItemDecoration(30)
        addItemDecoration(topSpacingDecoration)
        adapter = blogAdapter
    }
}

// onPostClickListener
private val onPostClickListener = object : BlogRecyclerAdapter.OnPostClickListener{
    override fun onClick(blogPost: BlogPost) {
      Toast.makeText(applicationContext, blogPost.username, Toast.LENGTH_SHORT).show()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전체적인-학습내용을-복습한다&quot;&gt;전체적인 학습내용을 복습한다.&lt;br /&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;RecyclerView를 사용할때 필요한 RecyclerViewAdapter클래스의 작성순서를 이미지 트레이닝한다.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 13 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/04/13/RecyclerView/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/13/RecyclerView/</guid>
        
        
        <category>Android</category>
        
      </item>
    
  </channel>
</rss>
